


	// ***** AUTOGENERATED CODE, DO NOT EDIT *****
    
        #include "REcmaShellGraphicsViewWorker.h"
        #include "RMetaTypes.h"
        #include "../REcmaHelper.h"

        // forwards declarations mapped to includes
        
                #include "RAction.h"
            
                #include "RDocument.h"
            
                #include "RDocumentInterface.h"
            
                #include "RGraphicsSceneQt.h"
            
                #include "RGraphicsSceneDrawable.h"
            
                #include "RLine.h"
            
                #include "RSnap.h"
            
                #include "RSnapRestriction.h"
            
                #include "RGraphicsViewImage.h"
            
            
        // includes for base ecma wrapper classes
        
            #include "REcmaGraphicsView.h"
          

            #define QTSCRIPT_IS_GENERATED_FUNCTION(fun) ((fun.data().toUInt32() & 0xFFFF0000) == 0xBABE0000)
            #define QTSCRIPT_IS_FUNCTION_IN_CALL(fun) ((fun.data().toUInt32() & 0x0000F000) == 0x0000B000)

        
    // Destructor:
    REcmaShellGraphicsViewWorker::~REcmaShellGraphicsViewWorker() {}
        RGraphicsViewWorker* REcmaShellGraphicsViewImage::getSelf(const QString& fName, QScriptContext* context)
    
        {
            RGraphicsViewWorker* self = NULL;

            
                // self could be a normal object (e.g. from an UI file) or
                // an ECMA shell object (made from an ECMA script):
                //self = getSelfShell(fName, context);
                

            //if (self==NULL) {
                self = REcmaHelper::scriptValueTo<RGraphicsViewWorker >(context->thisObject())
                
                ;
            //}

            if (self == NULL){
                // avoid recursion (toString is used by the backtrace):
                if (fName!="toString") {
                    REcmaHelper::throwError(QString("RGraphicsViewWorker.%1(): "
                        "This object is not a RGraphicsViewWorker").arg(fName),
                        context);
                }
                return NULL;
            }

            return self;
        }
        REcmaShellGraphicsViewWorker* REcmaShellGraphicsViewImage::getSelfShell(const QString& fName, QScriptContext* context)
    
        {
          RGraphicsViewWorker* selfBase = getSelf(fName, context);
                REcmaShellGraphicsViewWorker* self = dynamic_cast<REcmaShellGraphicsViewWorker*>(selfBase);
                //return REcmaHelper::scriptValueTo<REcmaShellGraphicsViewWorker >(context->thisObject());
            if(self == NULL){
                REcmaHelper::throwError(QString("RGraphicsViewWorker.%1(): "
                    "This object is not a RGraphicsViewWorker").arg(fName),
                    context);
            }

            return self;
            


        }
        
    
    
    
    // Constructors:
    
      REcmaShellGraphicsViewWorker::REcmaShellGraphicsViewWorker(
                QObject * parent
            ) : RGraphicsViewWorker(
                parent
                ) {
            }
        
    
    
      int REcmaShellGraphicsViewWorker::getNumThreads(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getNumThreads", engine);
                QScriptValue _q_function = __qtscript_self.property("getNumThreads");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getNumThreads";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        int ret =
                        RGraphicsViewWorker::getNumThreads(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getNumThreads", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    int res;
                      
                          res = qscriptvalue_cast< 
                            int
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getNumThreads", engine);

                    
                            return res;
                          
            }
        
    
    
      void REcmaShellGraphicsViewWorker::setNumThreads(
                int n
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setNumThreads", engine);
                QScriptValue _q_function = __qtscript_self.property("setNumThreads");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setNumThreads";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setNumThreads(
                            n
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setNumThreads", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: int, copyable: true
        << qScriptValueFromValue(engine, 

        n
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setNumThreads", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::setViewportNumber(
                int n
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setViewportNumber", engine);
                QScriptValue _q_function = __qtscript_self.property("setViewportNumber");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setViewportNumber";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setViewportNumber(
                            n
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setViewportNumber", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: int, copyable: true
        << qScriptValueFromValue(engine, 

        n
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setViewportNumber", engine);

                    
            }
        
    
    
      int REcmaShellGraphicsViewWorker::getViewportNumber(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getViewportNumber", engine);
                QScriptValue _q_function = __qtscript_self.property("getViewportNumber");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getViewportNumber";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        int ret =
                        RGraphicsViewWorker::getViewportNumber(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getViewportNumber", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    int res;
                      
                          res = qscriptvalue_cast< 
                            int
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getViewportNumber", engine);

                    
                            return res;
                          
            }
        
    
    
      void REcmaShellGraphicsViewWorker::setNavigationAction(
                RAction * action
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setNavigationAction", engine);
                QScriptValue _q_function = __qtscript_self.property("setNavigationAction");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setNavigationAction";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setNavigationAction(
                            action
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setNavigationAction", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RAction *, copyable: false
        << qScriptValueFromValue(engine, 

        action
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setNavigationAction", engine);

                    
            }
        
    
    
      RBox REcmaShellGraphicsViewWorker::getBox(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getBox", engine);
                QScriptValue _q_function = __qtscript_self.property("getBox");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getBox";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RBox ret =
                        RGraphicsViewWorker::getBox(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getBox", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    RBox res;
                      
                          res = qscriptvalue_cast< 
                            RBox
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getBox", engine);

                    
                            return res;
                          
            }
        
    
    
      void REcmaShellGraphicsViewWorker::autoZoom(
                int margin, bool ignoreEmpty, bool ignoreLineweight
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::autoZoom", engine);
                QScriptValue _q_function = __qtscript_self.property("autoZoom");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=3*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::autoZoom";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::autoZoom(
                            margin, ignoreEmpty, ignoreLineweight
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::autoZoom", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: int, copyable: true
        << qScriptValueFromValue(engine, 

        margin
        )
      



    // type: bool, copyable: true
        << qScriptValueFromValue(engine, 

        ignoreEmpty
        )
      



    // type: bool, copyable: true
        << qScriptValueFromValue(engine, 

        ignoreLineweight
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::autoZoom", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::zoomTo(
                const RBox & window, int margin
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::zoomTo", engine);
                QScriptValue _q_function = __qtscript_self.property("zoomTo");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=2*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::zoomTo";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::zoomTo(
                            window, margin
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::zoomTo", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RBox &, copyable: true
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new RBox(window)
        )
      



    // type: int, copyable: true
        << qScriptValueFromValue(engine, 

        margin
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::zoomTo", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::zoom(
                const RVector & center, double factor
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::zoom", engine);
                QScriptValue _q_function = __qtscript_self.property("zoom");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=2*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::zoom";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::zoom(
                            center, factor
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::zoom", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RVector &, copyable: true
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new RVector(center)
        )
      



    // type: double, copyable: true
        << qScriptValueFromValue(engine, 

        factor
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::zoom", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::pan(
                const RVector & delta, bool regen
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::pan", engine);
                QScriptValue _q_function = __qtscript_self.property("pan");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=2*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::pan";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::pan(
                            delta, regen
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::pan", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RVector &, copyable: true
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new RVector(delta)
        )
      



    // type: bool, copyable: true
        << qScriptValueFromValue(engine, 

        regen
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::pan", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::centerToBox(
                const RBox & box
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::centerToBox", engine);
                QScriptValue _q_function = __qtscript_self.property("centerToBox");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::centerToBox";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::centerToBox(
                            box
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::centerToBox", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RBox &, copyable: true
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new RBox(box)
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::centerToBox", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::centerToPoint(
                const RVector & point
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::centerToPoint", engine);
                QScriptValue _q_function = __qtscript_self.property("centerToPoint");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::centerToPoint";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::centerToPoint(
                            point
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::centerToPoint", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RVector &, copyable: true
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new RVector(point)
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::centerToPoint", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::setGrid(
                RGrid * grid
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setGrid", engine);
                QScriptValue _q_function = __qtscript_self.property("setGrid");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setGrid";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setGrid(
                            grid
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setGrid", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RGrid *, copyable: false
        << qScriptValueFromValue(engine, 

        grid
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setGrid", engine);

                    
            }
        
    
    
      RGrid * REcmaShellGraphicsViewWorker::getGrid(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getGrid", engine);
                QScriptValue _q_function = __qtscript_self.property("getGrid");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getGrid";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGrid * ret =
                        RGraphicsViewWorker::getGrid(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getGrid", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    RGrid * res;
                      
                          res = qscriptvalue_cast< 
                            RGrid *
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getGrid", engine);

                    
                            return res;
                          
            }
        
    
    
      double REcmaShellGraphicsViewWorker::getFactor(
                bool includeStepFactor
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getFactor", engine);
                QScriptValue _q_function = __qtscript_self.property("getFactor");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getFactor";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        double ret =
                        RGraphicsViewWorker::getFactor(
                            includeStepFactor
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getFactor", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    double res;
                      
                          res = qscriptvalue_cast< 
                            double
                          >(
                        
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: bool, copyable: true
        << qScriptValueFromValue(engine, 

        includeStepFactor
        )
      
                            )
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getFactor", engine);

                    
                            return res;
                          
            }
        
    
    
      void REcmaShellGraphicsViewWorker::setFactor(
                double f, bool regen
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setFactor", engine);
                QScriptValue _q_function = __qtscript_self.property("setFactor");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=2*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setFactor";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setFactor(
                            f, regen
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setFactor", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: double, copyable: true
        << qScriptValueFromValue(engine, 

        f
        )
      



    // type: bool, copyable: true
        << qScriptValueFromValue(engine, 

        regen
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setFactor", engine);

                    
            }
        
    
    
      RVector REcmaShellGraphicsViewWorker::getOffset(
                bool includeStepOffset
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getOffset", engine);
                QScriptValue _q_function = __qtscript_self.property("getOffset");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getOffset";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RVector ret =
                        RGraphicsViewWorker::getOffset(
                            includeStepOffset
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getOffset", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    RVector res;
                      
                          res = qscriptvalue_cast< 
                            RVector
                          >(
                        
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: bool, copyable: true
        << qScriptValueFromValue(engine, 

        includeStepOffset
        )
      
                            )
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getOffset", engine);

                    
                            return res;
                          
            }
        
    
    
      void REcmaShellGraphicsViewWorker::setOffset(
                const RVector & offset, bool regen
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setOffset", engine);
                QScriptValue _q_function = __qtscript_self.property("setOffset");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=2*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setOffset";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setOffset(
                            offset, regen
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setOffset", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RVector &, copyable: true
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new RVector(offset)
        )
      



    // type: bool, copyable: true
        << qScriptValueFromValue(engine, 

        regen
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setOffset", engine);

                    
            }
        
    
    
      QColor REcmaShellGraphicsViewWorker::getBackgroundColor(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getBackgroundColor", engine);
                QScriptValue _q_function = __qtscript_self.property("getBackgroundColor");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getBackgroundColor";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        QColor ret =
                        RGraphicsViewWorker::getBackgroundColor(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getBackgroundColor", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    QColor res;
                      
                          res = qscriptvalue_cast< 
                            QColor
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getBackgroundColor", engine);

                    
                            return res;
                          
            }
        
    
    
      void REcmaShellGraphicsViewWorker::setMargin(
                int m
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setMargin", engine);
                QScriptValue _q_function = __qtscript_self.property("setMargin");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setMargin";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setMargin(
                            m
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setMargin", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: int, copyable: true
        << qScriptValueFromValue(engine, 

        m
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setMargin", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::setColorMode(
                RGraphicsView::ColorMode cm
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setColorMode", engine);
                QScriptValue _q_function = __qtscript_self.property("setColorMode");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setColorMode";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setColorMode(
                            cm
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setColorMode", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RGraphicsView::ColorMode, copyable: true
        << qScriptValueFromValue(engine, 

        cm
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setColorMode", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::setHairlineMode(
                bool on
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setHairlineMode", engine);
                QScriptValue _q_function = __qtscript_self.property("setHairlineMode");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setHairlineMode";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setHairlineMode(
                            on
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setHairlineMode", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: bool, copyable: true
        << qScriptValueFromValue(engine, 

        on
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setHairlineMode", engine);

                    
            }
        
    
    
      bool REcmaShellGraphicsViewWorker::getHairlineMode(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getHairlineMode", engine);
                QScriptValue _q_function = __qtscript_self.property("getHairlineMode");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getHairlineMode";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        bool ret =
                        RGraphicsViewWorker::getHairlineMode(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getHairlineMode", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    bool res;
                      
                          res = qscriptvalue_cast< 
                            bool
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getHairlineMode", engine);

                    
                            return res;
                          
            }
        
    
    
      void REcmaShellGraphicsViewWorker::setHairlineMinimumMode(
                bool on
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setHairlineMinimumMode", engine);
                QScriptValue _q_function = __qtscript_self.property("setHairlineMinimumMode");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setHairlineMinimumMode";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setHairlineMinimumMode(
                            on
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setHairlineMinimumMode", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: bool, copyable: true
        << qScriptValueFromValue(engine, 

        on
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setHairlineMinimumMode", engine);

                    
            }
        
    
    
      bool REcmaShellGraphicsViewWorker::getHairlineMinimumMode(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getHairlineMinimumMode", engine);
                QScriptValue _q_function = __qtscript_self.property("getHairlineMinimumMode");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getHairlineMinimumMode";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        bool ret =
                        RGraphicsViewWorker::getHairlineMinimumMode(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getHairlineMinimumMode", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    bool res;
                      
                          res = qscriptvalue_cast< 
                            bool
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getHairlineMinimumMode", engine);

                    
                            return res;
                          
            }
        
    
    
      bool REcmaShellGraphicsViewWorker::getAntialiasing(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getAntialiasing", engine);
                QScriptValue _q_function = __qtscript_self.property("getAntialiasing");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getAntialiasing";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        bool ret =
                        RGraphicsViewWorker::getAntialiasing(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getAntialiasing", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    bool res;
                      
                          res = qscriptvalue_cast< 
                            bool
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getAntialiasing", engine);

                    
                            return res;
                          
            }
        
    
    
      RGraphicsScene * REcmaShellGraphicsViewWorker::getScene(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getScene", engine);
                QScriptValue _q_function = __qtscript_self.property("getScene");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getScene";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsScene * ret =
                        RGraphicsViewWorker::getScene(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getScene", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    RGraphicsScene * res;
                      
                          res = qscriptvalue_cast< 
                            RGraphicsScene *
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getScene", engine);

                    
                            return res;
                          
            }
        
    
    
      RDocument * REcmaShellGraphicsViewWorker::getDocument(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getDocument", engine);
                QScriptValue _q_function = __qtscript_self.property("getDocument");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getDocument";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RDocument * ret =
                        RGraphicsViewWorker::getDocument(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getDocument", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    RDocument * res;
                      
                          res = qscriptvalue_cast< 
                            RDocument *
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getDocument", engine);

                    
                            return res;
                          
            }
        
    
    
      RDocumentInterface * REcmaShellGraphicsViewWorker::getDocumentInterface(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getDocumentInterface", engine);
                QScriptValue _q_function = __qtscript_self.property("getDocumentInterface");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getDocumentInterface";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RDocumentInterface * ret =
                        RGraphicsViewWorker::getDocumentInterface(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getDocumentInterface", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    RDocumentInterface * res;
                      
                          res = qscriptvalue_cast< 
                            RDocumentInterface *
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getDocumentInterface", engine);

                    
                            return res;
                          
            }
        
    
    
      void REcmaShellGraphicsViewWorker::setExporting(
                bool on
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setExporting", engine);
                QScriptValue _q_function = __qtscript_self.property("setExporting");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setExporting";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setExporting(
                            on
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setExporting", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: bool, copyable: true
        << qScriptValueFromValue(engine, 

        on
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setExporting", engine);

                    
            }
        
    
    
      bool REcmaShellGraphicsViewWorker::isExporting(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::isExporting", engine);
                QScriptValue _q_function = __qtscript_self.property("isExporting");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::isExporting";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        bool ret =
                        RGraphicsViewWorker::isExporting(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::isExporting", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    bool res;
                      
                          res = qscriptvalue_cast< 
                            bool
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::isExporting", engine);

                    
                            return res;
                          
            }
        
    
    
      bool REcmaShellGraphicsViewWorker::isPrintingOrExporting(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::isPrintingOrExporting", engine);
                QScriptValue _q_function = __qtscript_self.property("isPrintingOrExporting");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::isPrintingOrExporting";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        bool ret =
                        RGraphicsViewWorker::isPrintingOrExporting(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::isPrintingOrExporting", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    bool res;
                      
                          res = qscriptvalue_cast< 
                            bool
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::isPrintingOrExporting", engine);

                    
                            return res;
                          
            }
        
    
    
      void REcmaShellGraphicsViewWorker::setPrinting(
                bool on
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setPrinting", engine);
                QScriptValue _q_function = __qtscript_self.property("setPrinting");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setPrinting";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setPrinting(
                            on
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setPrinting", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: bool, copyable: true
        << qScriptValueFromValue(engine, 

        on
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setPrinting", engine);

                    
            }
        
    
    
      bool REcmaShellGraphicsViewWorker::isPrinting(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::isPrinting", engine);
                QScriptValue _q_function = __qtscript_self.property("isPrinting");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::isPrinting";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        bool ret =
                        RGraphicsViewWorker::isPrinting(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::isPrinting", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    bool res;
                      
                          res = qscriptvalue_cast< 
                            bool
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::isPrinting", engine);

                    
                            return res;
                          
            }
        
    
    
      void REcmaShellGraphicsViewWorker::setPrintPreview(
                bool on
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setPrintPreview", engine);
                QScriptValue _q_function = __qtscript_self.property("setPrintPreview");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setPrintPreview";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setPrintPreview(
                            on
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setPrintPreview", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: bool, copyable: true
        << qScriptValueFromValue(engine, 

        on
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setPrintPreview", engine);

                    
            }
        
    
    
      bool REcmaShellGraphicsViewWorker::isPrintPreview(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::isPrintPreview", engine);
                QScriptValue _q_function = __qtscript_self.property("isPrintPreview");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::isPrintPreview";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        bool ret =
                        RGraphicsViewWorker::isPrintPreview(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::isPrintPreview", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    bool res;
                      
                          res = qscriptvalue_cast< 
                            bool
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::isPrintPreview", engine);

                    
                            return res;
                          
            }
        
    
    
      void REcmaShellGraphicsViewWorker::setPrintPointSize(
                const RVector & s
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setPrintPointSize", engine);
                QScriptValue _q_function = __qtscript_self.property("setPrintPointSize");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setPrintPointSize";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setPrintPointSize(
                            s
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setPrintPointSize", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RVector &, copyable: true
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new RVector(s)
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setPrintPointSize", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::simulateMouseMoveEvent(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::simulateMouseMoveEvent", engine);
                QScriptValue _q_function = __qtscript_self.property("simulateMouseMoveEvent");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::simulateMouseMoveEvent";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::simulateMouseMoveEvent(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::simulateMouseMoveEvent", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self)
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::simulateMouseMoveEvent", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::setTextHeightThresholdOverride(
                int v
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setTextHeightThresholdOverride", engine);
                QScriptValue _q_function = __qtscript_self.property("setTextHeightThresholdOverride");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setTextHeightThresholdOverride";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setTextHeightThresholdOverride(
                            v
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setTextHeightThresholdOverride", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: int, copyable: true
        << qScriptValueFromValue(engine, 

        v
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setTextHeightThresholdOverride", engine);

                    
            }
        
    
    
      int REcmaShellGraphicsViewWorker::getTextHeightThresholdOverride(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getTextHeightThresholdOverride", engine);
                QScriptValue _q_function = __qtscript_self.property("getTextHeightThresholdOverride");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getTextHeightThresholdOverride";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        int ret =
                        RGraphicsViewWorker::getTextHeightThresholdOverride(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getTextHeightThresholdOverride", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    int res;
                      
                          res = qscriptvalue_cast< 
                            int
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getTextHeightThresholdOverride", engine);

                    
                            return res;
                          
            }
        
    
    
      bool REcmaShellGraphicsViewWorker::isGridVisible(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::isGridVisible", engine);
                QScriptValue _q_function = __qtscript_self.property("isGridVisible");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::isGridVisible";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        bool ret =
                        RGraphicsViewWorker::isGridVisible(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::isGridVisible", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    bool res;
                      
                          res = qscriptvalue_cast< 
                            bool
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::isGridVisible", engine);

                    
                            return res;
                          
            }
        
    
    
      void REcmaShellGraphicsViewWorker::setGridVisible(
                bool on
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setGridVisible", engine);
                QScriptValue _q_function = __qtscript_self.property("setGridVisible");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setGridVisible";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setGridVisible(
                            on
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setGridVisible", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: bool, copyable: true
        << qScriptValueFromValue(engine, 

        on
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setGridVisible", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::setScene(
                RGraphicsSceneQt * scene, bool regen
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setScene", engine);
                QScriptValue _q_function = __qtscript_self.property("setScene");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=2*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setScene";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setScene(
                            scene, regen
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setScene", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RGraphicsSceneQt *, copyable: false
        << qScriptValueFromValue(engine, 

        scene
        )
      



    // type: bool, copyable: true
        << qScriptValueFromValue(engine, 

        regen
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setScene", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::setBackgroundColor(
                const QColor & col
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setBackgroundColor", engine);
                QScriptValue _q_function = __qtscript_self.property("setBackgroundColor");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setBackgroundColor";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setBackgroundColor(
                            col
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setBackgroundColor", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: QColor &, copyable: true
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new QColor(col)
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setBackgroundColor", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::regenerate(
                bool force
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::regenerate", engine);
                QScriptValue _q_function = __qtscript_self.property("regenerate");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::regenerate";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::regenerate(
                            force
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::regenerate", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: bool, copyable: true
        << qScriptValueFromValue(engine, 

        force
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::regenerate", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::repaintView(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::repaintView", engine);
                QScriptValue _q_function = __qtscript_self.property("repaintView");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::repaintView";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::repaintView(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::repaintView", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self)
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::repaintView", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::updateImage(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::updateImage", engine);
                QScriptValue _q_function = __qtscript_self.property("updateImage");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::updateImage";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::updateImage(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::updateImage", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self)
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::updateImage", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::giveFocus(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::giveFocus", engine);
                QScriptValue _q_function = __qtscript_self.property("giveFocus");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::giveFocus";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::giveFocus(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::giveFocus", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self)
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::giveFocus", engine);

                    
            }
        
    
    
      bool REcmaShellGraphicsViewWorker::hasFocus(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::hasFocus", engine);
                QScriptValue _q_function = __qtscript_self.property("hasFocus");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::hasFocus";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        bool ret =
                        RGraphicsViewWorker::hasFocus(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::hasFocus", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    bool res;
                      
                          res = qscriptvalue_cast< 
                            bool
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::hasFocus", engine);

                    
                            return res;
                          
            }
        
    
    
      void REcmaShellGraphicsViewWorker::removeFocus(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::removeFocus", engine);
                QScriptValue _q_function = __qtscript_self.property("removeFocus");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::removeFocus";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::removeFocus(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::removeFocus", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self)
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::removeFocus", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::saveViewport(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::saveViewport", engine);
                QScriptValue _q_function = __qtscript_self.property("saveViewport");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::saveViewport";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::saveViewport(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::saveViewport", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self)
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::saveViewport", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::restoreViewport(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::restoreViewport", engine);
                QScriptValue _q_function = __qtscript_self.property("restoreViewport");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::restoreViewport";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::restoreViewport(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::restoreViewport", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self)
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::restoreViewport", engine);

                    
            }
        
    
    
      RVector REcmaShellGraphicsViewWorker::mapFromView(
                const RVector & v, double z
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::mapFromView", engine);
                QScriptValue _q_function = __qtscript_self.property("mapFromView");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=2*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::mapFromView";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RVector ret =
                        RGraphicsViewWorker::mapFromView(
                            v, z
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::mapFromView", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    RVector res;
                      
                          res = qscriptvalue_cast< 
                            RVector
                          >(
                        
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RVector &, copyable: true
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new RVector(v)
        )
      



    // type: double, copyable: true
        << qScriptValueFromValue(engine, 

        z
        )
      
                            )
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::mapFromView", engine);

                    
                            return res;
                          
            }
        
    
    
      RVector REcmaShellGraphicsViewWorker::mapToView(
                const RVector & v
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::mapToView", engine);
                QScriptValue _q_function = __qtscript_self.property("mapToView");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::mapToView";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RVector ret =
                        RGraphicsViewWorker::mapToView(
                            v
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::mapToView", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    RVector res;
                      
                          res = qscriptvalue_cast< 
                            RVector
                          >(
                        
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RVector &, copyable: true
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new RVector(v)
        )
      
                            )
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::mapToView", engine);

                    
                            return res;
                          
            }
        
    
    
      double REcmaShellGraphicsViewWorker::mapDistanceFromView(
                double d
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::mapDistanceFromView", engine);
                QScriptValue _q_function = __qtscript_self.property("mapDistanceFromView");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::mapDistanceFromView";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        double ret =
                        RGraphicsViewWorker::mapDistanceFromView(
                            d
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::mapDistanceFromView", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    double res;
                      
                          res = qscriptvalue_cast< 
                            double
                          >(
                        
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: double, copyable: true
        << qScriptValueFromValue(engine, 

        d
        )
      
                            )
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::mapDistanceFromView", engine);

                    
                            return res;
                          
            }
        
    
    
      double REcmaShellGraphicsViewWorker::mapDistanceToView(
                double d
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::mapDistanceToView", engine);
                QScriptValue _q_function = __qtscript_self.property("mapDistanceToView");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::mapDistanceToView";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        double ret =
                        RGraphicsViewWorker::mapDistanceToView(
                            d
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::mapDistanceToView", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    double res;
                      
                          res = qscriptvalue_cast< 
                            double
                          >(
                        
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: double, copyable: true
        << qScriptValueFromValue(engine, 

        d
        )
      
                            )
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::mapDistanceToView", engine);

                    
                            return res;
                          
            }
        
    
    
      int REcmaShellGraphicsViewWorker::getWidth(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getWidth", engine);
                QScriptValue _q_function = __qtscript_self.property("getWidth");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getWidth";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        int ret =
                        RGraphicsViewWorker::getWidth(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getWidth", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    int res;
                      
                          res = qscriptvalue_cast< 
                            int
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getWidth", engine);

                    
                            return res;
                          
            }
        
    
    
      int REcmaShellGraphicsViewWorker::getHeight(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getHeight", engine);
                QScriptValue _q_function = __qtscript_self.property("getHeight");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getHeight";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        int ret =
                        RGraphicsViewWorker::getHeight(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getHeight", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    int res;
                      
                          res = qscriptvalue_cast< 
                            int
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getHeight", engine);

                    
                            return res;
                          
            }
        
    
    
      void REcmaShellGraphicsViewWorker::resizeImage(
                int w, int h
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::resizeImage", engine);
                QScriptValue _q_function = __qtscript_self.property("resizeImage");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=2*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::resizeImage";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::resizeImage(
                            w, h
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::resizeImage", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: int, copyable: true
        << qScriptValueFromValue(engine, 

        w
        )
      



    // type: int, copyable: true
        << qScriptValueFromValue(engine, 

        h
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::resizeImage", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::paintGridPoint(
                const RVector & ucsPosition
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::paintGridPoint", engine);
                QScriptValue _q_function = __qtscript_self.property("paintGridPoint");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::paintGridPoint";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::paintGridPoint(
                            ucsPosition
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::paintGridPoint", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RVector &, copyable: true
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new RVector(ucsPosition)
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::paintGridPoint", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::paintGridLine(
                const RLine & ucsPosition
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::paintGridLine", engine);
                QScriptValue _q_function = __qtscript_self.property("paintGridLine");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::paintGridLine";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::paintGridLine(
                            ucsPosition
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::paintGridLine", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RLine &, copyable: true
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new RLine(ucsPosition)
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::paintGridLine", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::paintCursorLine(
                const RLine & ucsPosition
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::paintCursorLine", engine);
                QScriptValue _q_function = __qtscript_self.property("paintCursorLine");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::paintCursorLine";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::paintCursorLine(
                            ucsPosition
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::paintCursorLine", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RLine &, copyable: true
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new RLine(ucsPosition)
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::paintCursorLine", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::setPaintOrigin(
                bool val
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setPaintOrigin", engine);
                QScriptValue _q_function = __qtscript_self.property("setPaintOrigin");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setPaintOrigin";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setPaintOrigin(
                            val
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setPaintOrigin", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: bool, copyable: true
        << qScriptValueFromValue(engine, 

        val
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setPaintOrigin", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::setPanOptimization(
                bool on
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setPanOptimization", engine);
                QScriptValue _q_function = __qtscript_self.property("setPanOptimization");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setPanOptimization";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setPanOptimization(
                            on
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setPanOptimization", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: bool, copyable: true
        << qScriptValueFromValue(engine, 

        on
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setPanOptimization", engine);

                    
            }
        
    
    
      bool REcmaShellGraphicsViewWorker::getPanOptimization(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getPanOptimization", engine);
                QScriptValue _q_function = __qtscript_self.property("getPanOptimization");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getPanOptimization";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        bool ret =
                        RGraphicsViewWorker::getPanOptimization(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getPanOptimization", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    bool res;
                      
                          res = qscriptvalue_cast< 
                            bool
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getPanOptimization", engine);

                    
                            return res;
                          
            }
        
    
    
      void REcmaShellGraphicsViewWorker::paintEntitiesMulti(
                const RBox & queryBox
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::paintEntitiesMulti", engine);
                QScriptValue _q_function = __qtscript_self.property("paintEntitiesMulti");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::paintEntitiesMulti";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::paintEntitiesMulti(
                            queryBox
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::paintEntitiesMulti", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RBox &, copyable: true
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new RBox(queryBox)
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::paintEntitiesMulti", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::paintEntityThread(
                RGraphicsViewWorker * worker, REntity::Id id, bool preview
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::paintEntityThread", engine);
                QScriptValue _q_function = __qtscript_self.property("paintEntityThread");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=3*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::paintEntityThread";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::paintEntityThread(
                            worker, id, preview
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::paintEntityThread", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RGraphicsViewWorker *, copyable: false
        << qScriptValueFromValue(engine, 

        worker
        )
      



    // type: REntity::Id, copyable: true
        << qScriptValueFromValue(engine, 

        id
        )
      



    // type: bool, copyable: true
        << qScriptValueFromValue(engine, 

        preview
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::paintEntityThread", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::paintDrawableThread(
                RGraphicsViewWorker * worker, RGraphicsSceneDrawable & drawable, const RBox & clipRectangle, bool preview
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::paintDrawableThread", engine);
                QScriptValue _q_function = __qtscript_self.property("paintDrawableThread");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=4*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::paintDrawableThread";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::paintDrawableThread(
                            worker, drawable, clipRectangle, preview
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::paintDrawableThread", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RGraphicsViewWorker *, copyable: false
        << qScriptValueFromValue(engine, 

        worker
        )
      



    // type: RGraphicsSceneDrawable &, copyable: true
        << qScriptValueFromValue(engine, 

        drawable
        )
      



    // type: RBox &, copyable: true
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new RBox(clipRectangle)
        )
      



    // type: bool, copyable: true
        << qScriptValueFromValue(engine, 

        preview
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::paintDrawableThread", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::paintOverlay(
                RGraphicsViewWorker * worker
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::paintOverlay", engine);
                QScriptValue _q_function = __qtscript_self.property("paintOverlay");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::paintOverlay";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::paintOverlay(
                            worker
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::paintOverlay", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RGraphicsViewWorker *, copyable: false
        << qScriptValueFromValue(engine, 

        worker
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::paintOverlay", engine);

                    
            }
        
    
    
      QImage REcmaShellGraphicsViewWorker::getBuffer(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getBuffer", engine);
                QScriptValue _q_function = __qtscript_self.property("getBuffer");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getBuffer";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        QImage ret =
                        RGraphicsViewWorker::getBuffer(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getBuffer", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    QImage res;
                      
                          res = qscriptvalue_cast< 
                            QImage
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getBuffer", engine);

                    
                            return res;
                          
            }
        
    
    
      void REcmaShellGraphicsViewWorker::clearBackground(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::clearBackground", engine);
                QScriptValue _q_function = __qtscript_self.property("clearBackground");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::clearBackground";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::clearBackground(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::clearBackground", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self)
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::clearBackground", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::addToBackground(
                const RGraphicsSceneDrawable & drawable
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::addToBackground", engine);
                QScriptValue _q_function = __qtscript_self.property("addToBackground");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::addToBackground";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::addToBackground(
                            drawable
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::addToBackground", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RGraphicsSceneDrawable &, copyable: true
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new RGraphicsSceneDrawable(drawable)
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::addToBackground", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::setBackgroundTransform(
                double bgFactor, const RVector & bgOffset
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setBackgroundTransform", engine);
                QScriptValue _q_function = __qtscript_self.property("setBackgroundTransform");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=2*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setBackgroundTransform";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setBackgroundTransform(
                            bgFactor, bgOffset
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setBackgroundTransform", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: double, copyable: true
        << qScriptValueFromValue(engine, 

        bgFactor
        )
      



    // type: RVector &, copyable: true
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new RVector(bgOffset)
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setBackgroundTransform", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::clearOverlay(
                int overlayId
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::clearOverlay", engine);
                QScriptValue _q_function = __qtscript_self.property("clearOverlay");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::clearOverlay";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::clearOverlay(
                            overlayId
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::clearOverlay", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: int, copyable: true
        << qScriptValueFromValue(engine, 

        overlayId
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::clearOverlay", engine);

                    
            }
        
      void REcmaShellGraphicsViewWorker::clearOverlay(
                int overlayId, RObject::Id objectId
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::clearOverlay", engine);
                QScriptValue _q_function = __qtscript_self.property("clearOverlay");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=2*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::clearOverlay";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::clearOverlay(
                            overlayId, objectId
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::clearOverlay", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: int, copyable: true
        << qScriptValueFromValue(engine, 

        overlayId
        )
      



    // type: RObject::Id, copyable: true
        << qScriptValueFromValue(engine, 

        objectId
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::clearOverlay", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::addToOverlay(
                int overlayId, RObject::Id objectId, const RGraphicsSceneDrawable & drawable
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::addToOverlay", engine);
                QScriptValue _q_function = __qtscript_self.property("addToOverlay");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=3*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::addToOverlay";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::addToOverlay(
                            overlayId, objectId, drawable
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::addToOverlay", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: int, copyable: true
        << qScriptValueFromValue(engine, 

        overlayId
        )
      



    // type: RObject::Id, copyable: true
        << qScriptValueFromValue(engine, 

        objectId
        )
      



    // type: RGraphicsSceneDrawable &, copyable: true
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new RGraphicsSceneDrawable(drawable)
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::addToOverlay", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::setColorCorrectionOverride(
                bool on
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setColorCorrectionOverride", engine);
                QScriptValue _q_function = __qtscript_self.property("setColorCorrectionOverride");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setColorCorrectionOverride";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setColorCorrectionOverride(
                            on
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setColorCorrectionOverride", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: bool, copyable: true
        << qScriptValueFromValue(engine, 

        on
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setColorCorrectionOverride", engine);

                    
            }
        
    
    
      bool REcmaShellGraphicsViewWorker::getColorCorrectionOverride(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getColorCorrectionOverride", engine);
                QScriptValue _q_function = __qtscript_self.property("getColorCorrectionOverride");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getColorCorrectionOverride";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        bool ret =
                        RGraphicsViewWorker::getColorCorrectionOverride(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getColorCorrectionOverride", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    bool res;
                      
                          res = qscriptvalue_cast< 
                            bool
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getColorCorrectionOverride", engine);

                    
                            return res;
                          
            }
        
    
    
      void REcmaShellGraphicsViewWorker::setMinimumLineweight(
                double lw
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setMinimumLineweight", engine);
                QScriptValue _q_function = __qtscript_self.property("setMinimumLineweight");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setMinimumLineweight";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setMinimumLineweight(
                            lw
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setMinimumLineweight", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: double, copyable: true
        << qScriptValueFromValue(engine, 

        lw
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setMinimumLineweight", engine);

                    
            }
        
    
    
      double REcmaShellGraphicsViewWorker::getMinimumLineweight(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getMinimumLineweight", engine);
                QScriptValue _q_function = __qtscript_self.property("getMinimumLineweight");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getMinimumLineweight";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        double ret =
                        RGraphicsViewWorker::getMinimumLineweight(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getMinimumLineweight", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    double res;
                      
                          res = qscriptvalue_cast< 
                            double
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getMinimumLineweight", engine);

                    
                            return res;
                          
            }
        
    
    
      void REcmaShellGraphicsViewWorker::setMaximumLineweight(
                double lw
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setMaximumLineweight", engine);
                QScriptValue _q_function = __qtscript_self.property("setMaximumLineweight");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setMaximumLineweight";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setMaximumLineweight(
                            lw
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setMaximumLineweight", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: double, copyable: true
        << qScriptValueFromValue(engine, 

        lw
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setMaximumLineweight", engine);

                    
            }
        
    
    
      double REcmaShellGraphicsViewWorker::getMaximumLineweight(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getMaximumLineweight", engine);
                QScriptValue _q_function = __qtscript_self.property("getMaximumLineweight");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getMaximumLineweight";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        double ret =
                        RGraphicsViewWorker::getMaximumLineweight(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getMaximumLineweight", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    double res;
                      
                          res = qscriptvalue_cast< 
                            double
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getMaximumLineweight", engine);

                    
                            return res;
                          
            }
        
    
    
      void REcmaShellGraphicsViewWorker::setPaintOffset(
                const RVector & offset
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setPaintOffset", engine);
                QScriptValue _q_function = __qtscript_self.property("setPaintOffset");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setPaintOffset";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setPaintOffset(
                            offset
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setPaintOffset", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RVector &, copyable: true
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new RVector(offset)
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setPaintOffset", engine);

                    
            }
        
    
    
      RVector REcmaShellGraphicsViewWorker::getPaintOffset(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getPaintOffset", engine);
                QScriptValue _q_function = __qtscript_self.property("getPaintOffset");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getPaintOffset";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RVector ret =
                        RGraphicsViewWorker::getPaintOffset(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getPaintOffset", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    RVector res;
                      
                          res = qscriptvalue_cast< 
                            RVector
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getPaintOffset", engine);

                    
                            return res;
                          
            }
        
    
    
      bool REcmaShellGraphicsViewWorker::isAlphaEnabled(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::isAlphaEnabled", engine);
                QScriptValue _q_function = __qtscript_self.property("isAlphaEnabled");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::isAlphaEnabled";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        bool ret =
                        RGraphicsViewWorker::isAlphaEnabled(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::isAlphaEnabled", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    bool res;
                      
                          res = qscriptvalue_cast< 
                            bool
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::isAlphaEnabled", engine);

                    
                            return res;
                          
            }
        
    
    
      void REcmaShellGraphicsViewWorker::setAlphaEnabled(
                bool on
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setAlphaEnabled", engine);
                QScriptValue _q_function = __qtscript_self.property("setAlphaEnabled");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setAlphaEnabled";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setAlphaEnabled(
                            on
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setAlphaEnabled", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: bool, copyable: true
        << qScriptValueFromValue(engine, 

        on
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setAlphaEnabled", engine);

                    
            }
        
    
    
      QImage REcmaShellGraphicsViewWorker::getGraphicsBufferWithPreview(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getGraphicsBufferWithPreview", engine);
                QScriptValue _q_function = __qtscript_self.property("getGraphicsBufferWithPreview");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getGraphicsBufferWithPreview";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        QImage ret =
                        RGraphicsViewWorker::getGraphicsBufferWithPreview(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getGraphicsBufferWithPreview", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    QImage res;
                      
                          res = qscriptvalue_cast< 
                            QImage
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getGraphicsBufferWithPreview", engine);

                    
                            return res;
                          
            }
        
    
    
      RVector REcmaShellGraphicsViewWorker::getLastKnownScreenPosition(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getLastKnownScreenPosition", engine);
                QScriptValue _q_function = __qtscript_self.property("getLastKnownScreenPosition");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getLastKnownScreenPosition";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RVector ret =
                        RGraphicsViewWorker::getLastKnownScreenPosition(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getLastKnownScreenPosition", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    RVector res;
                      
                          res = qscriptvalue_cast< 
                            RVector
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getLastKnownScreenPosition", engine);

                    
                            return res;
                          
            }
        
    
    
      void REcmaShellGraphicsViewWorker::setLastKnownScreenPosition(
                const RVector & p
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setLastKnownScreenPosition", engine);
                QScriptValue _q_function = __qtscript_self.property("setLastKnownScreenPosition");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setLastKnownScreenPosition";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setLastKnownScreenPosition(
                            p
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setLastKnownScreenPosition", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RVector &, copyable: true
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new RVector(p)
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setLastKnownScreenPosition", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::setLastKnownModelPosition(
                const RVector & p
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setLastKnownModelPosition", engine);
                QScriptValue _q_function = __qtscript_self.property("setLastKnownModelPosition");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setLastKnownModelPosition";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setLastKnownModelPosition(
                            p
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setLastKnownModelPosition", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RVector &, copyable: true
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new RVector(p)
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setLastKnownModelPosition", engine);

                    
            }
        
    
    
      bool REcmaShellGraphicsViewWorker::isShared(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::isShared", engine);
                QScriptValue _q_function = __qtscript_self.property("isShared");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::isShared";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        bool ret =
                        RGraphicsViewWorker::isShared(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::isShared", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    bool res;
                      
                          res = qscriptvalue_cast< 
                            bool
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::isShared", engine);

                    
                            return res;
                          
            }
        
    
    
      bool REcmaShellGraphicsViewWorker::registerForFocus(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::registerForFocus", engine);
                QScriptValue _q_function = __qtscript_self.property("registerForFocus");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::registerForFocus";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        bool ret =
                        RGraphicsViewWorker::registerForFocus(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::registerForFocus", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    bool res;
                      
                          res = qscriptvalue_cast< 
                            bool
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::registerForFocus", engine);

                    
                            return res;
                          
            }
        
    
    
      void REcmaShellGraphicsViewWorker::viewportChangeEvent(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::viewportChangeEvent", engine);
                QScriptValue _q_function = __qtscript_self.property("viewportChangeEvent");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::viewportChangeEvent";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::viewportChangeEvent(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::viewportChangeEvent", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self)
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::viewportChangeEvent", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::emitUpdateSnapInfo(
                RSnap * snap, RSnapRestriction * restriction
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::emitUpdateSnapInfo", engine);
                QScriptValue _q_function = __qtscript_self.property("emitUpdateSnapInfo");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=2*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::emitUpdateSnapInfo";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::emitUpdateSnapInfo(
                            snap, restriction
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::emitUpdateSnapInfo", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RSnap *, copyable: false
        << qScriptValueFromValue(engine, 

        snap
        )
      



    // type: RSnapRestriction *, copyable: false
        << qScriptValueFromValue(engine, 

        restriction
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::emitUpdateSnapInfo", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::emitUpdateTextLabel(
                const RTextLabel & textLabel
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::emitUpdateTextLabel", engine);
                QScriptValue _q_function = __qtscript_self.property("emitUpdateTextLabel");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::emitUpdateTextLabel";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::emitUpdateTextLabel(
                            textLabel
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::emitUpdateTextLabel", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RTextLabel &, copyable: true
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new RTextLabel(textLabel)
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::emitUpdateTextLabel", engine);

                    
            }
        
    
    
      double REcmaShellGraphicsViewWorker::getDevicePixelRatio(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getDevicePixelRatio", engine);
                QScriptValue _q_function = __qtscript_self.property("getDevicePixelRatio");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getDevicePixelRatio";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        double ret =
                        RGraphicsViewWorker::getDevicePixelRatio(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getDevicePixelRatio", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    double res;
                      
                          res = qscriptvalue_cast< 
                            double
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getDevicePixelRatio", engine);

                    
                            return res;
                          
            }
        
    
    
      QList < RPainterPath > REcmaShellGraphicsViewWorker::getTextLayoutsPainterPaths(
                const RTextBasedData & text, const QList < RTextLayout > & textLayouts
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getTextLayoutsPainterPaths", engine);
                QScriptValue _q_function = __qtscript_self.property("getTextLayoutsPainterPaths");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=2*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getTextLayoutsPainterPaths";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        QList < RPainterPath > ret =
                        RGraphicsViewWorker::getTextLayoutsPainterPaths(
                            text, textLayouts
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getTextLayoutsPainterPaths", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                        // temporary make protected function scriptable, only from the context of this function call:
                        QScriptValue proto = engine->defaultPrototype(qMetaTypeId<RGraphicsViewWorker*>());
                        REcmaHelper::registerFunction(engine, &proto, getTextLayoutsPainterPaths, "getTextLayoutsPainterPaths");
                        QList < RPainterPath > res;
                      
                          REcmaHelper::fromScriptValue(engine, 
                        
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RTextBasedData &, copyable: true
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new RTextBasedData(text)
        )
      



    // type: QList < RTextLayout > &, copyable: false
        // List of ...:
        << REcmaHelper::listToScriptValue(engine, 
          textLayouts
        )
      
                            )
                        
                      , res
                    
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getTextLayoutsPainterPaths", engine);

                    
                            return res;
                          
            }
        
    
    
      void REcmaShellGraphicsViewWorker::applyMinimumLineweight(
                QPen & pen
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::applyMinimumLineweight", engine);
                QScriptValue _q_function = __qtscript_self.property("applyMinimumLineweight");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::applyMinimumLineweight";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::applyMinimumLineweight(
                            pen
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::applyMinimumLineweight", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                        // temporary make protected function scriptable, only from the context of this function call:
                        QScriptValue proto = engine->defaultPrototype(qMetaTypeId<RGraphicsViewWorker*>());
                        REcmaHelper::registerFunction(engine, &proto, applyMinimumLineweight, "applyMinimumLineweight");
                        
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: QPen &, copyable: false
        << qScriptValueFromValue(engine, 

        &pen
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::applyMinimumLineweight", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::applyColorCorrection(
                QPen & pen
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::applyColorCorrection", engine);
                QScriptValue _q_function = __qtscript_self.property("applyColorCorrection");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::applyColorCorrection";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::applyColorCorrection(
                            pen
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::applyColorCorrection", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                        // temporary make protected function scriptable, only from the context of this function call:
                        QScriptValue proto = engine->defaultPrototype(qMetaTypeId<RGraphicsViewWorker*>());
                        REcmaHelper::registerFunction(engine, &proto, applyColorCorrection, "applyColorCorrection");
                        
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: QPen &, copyable: false
        << qScriptValueFromValue(engine, 

        &pen
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::applyColorCorrection", engine);

                    
            }
        
      void REcmaShellGraphicsViewWorker::applyColorCorrection(
                QBrush & brush
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::applyColorCorrection", engine);
                QScriptValue _q_function = __qtscript_self.property("applyColorCorrection");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::applyColorCorrection";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::applyColorCorrection(
                            brush
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::applyColorCorrection", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                        // temporary make protected function scriptable, only from the context of this function call:
                        QScriptValue proto = engine->defaultPrototype(qMetaTypeId<RGraphicsViewWorker*>());
                        REcmaHelper::registerFunction(engine, &proto, applyColorCorrection, "applyColorCorrection");
                        
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: QBrush &, copyable: false
        << qScriptValueFromValue(engine, 

        &brush
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::applyColorCorrection", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::applyColorMode(
                QPen & pen
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::applyColorMode", engine);
                QScriptValue _q_function = __qtscript_self.property("applyColorMode");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::applyColorMode";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::applyColorMode(
                            pen
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::applyColorMode", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                        // temporary make protected function scriptable, only from the context of this function call:
                        QScriptValue proto = engine->defaultPrototype(qMetaTypeId<RGraphicsViewWorker*>());
                        REcmaHelper::registerFunction(engine, &proto, applyColorMode, "applyColorMode");
                        
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: QPen &, copyable: false
        << qScriptValueFromValue(engine, 

        &pen
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::applyColorMode", engine);

                    
            }
        
      void REcmaShellGraphicsViewWorker::applyColorMode(
                QBrush & brush
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::applyColorMode", engine);
                QScriptValue _q_function = __qtscript_self.property("applyColorMode");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::applyColorMode";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::applyColorMode(
                            brush
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::applyColorMode", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                        // temporary make protected function scriptable, only from the context of this function call:
                        QScriptValue proto = engine->defaultPrototype(qMetaTypeId<RGraphicsViewWorker*>());
                        REcmaHelper::registerFunction(engine, &proto, applyColorMode, "applyColorMode");
                        
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: QBrush &, copyable: false
        << qScriptValueFromValue(engine, 

        &brush
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::applyColorMode", engine);

                    
            }
        
    
    
      double REcmaShellGraphicsViewWorker::getPointSize(
                double pSize
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getPointSize", engine);
                QScriptValue _q_function = __qtscript_self.property("getPointSize");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getPointSize";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        double ret =
                        RGraphicsViewWorker::getPointSize(
                            pSize
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getPointSize", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                        // temporary make protected function scriptable, only from the context of this function call:
                        QScriptValue proto = engine->defaultPrototype(qMetaTypeId<RGraphicsViewWorker*>());
                        REcmaHelper::registerFunction(engine, &proto, getPointSize, "getPointSize");
                        double res;
                      
                          res = qscriptvalue_cast< 
                            double
                          >(
                        
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: double, copyable: true
        << qScriptValueFromValue(engine, 

        pSize
        )
      
                            )
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getPointSize", engine);

                    
                            return res;
                          
            }
        
    
    
      void REcmaShellGraphicsViewWorker::drawDot(
                RGraphicsViewWorker * worker, QPointF pt
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::drawDot", engine);
                QScriptValue _q_function = __qtscript_self.property("drawDot");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=2*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::drawDot";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::drawDot(
                            worker, pt
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::drawDot", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                        // temporary make protected function scriptable, only from the context of this function call:
                        QScriptValue proto = engine->defaultPrototype(qMetaTypeId<RGraphicsViewWorker*>());
                        REcmaHelper::registerFunction(engine, &proto, drawDot, "drawDot");
                        
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RGraphicsViewWorker *, copyable: false
        << qScriptValueFromValue(engine, 

        worker
        )
      



    // type: QPointF, copyable: false
        << qScriptValueFromValue(engine, 

        pt
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::drawDot", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::drawPlus(
                RGraphicsViewWorker * worker, QPointF pt, double pSize
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::drawPlus", engine);
                QScriptValue _q_function = __qtscript_self.property("drawPlus");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=3*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::drawPlus";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::drawPlus(
                            worker, pt, pSize
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::drawPlus", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                        // temporary make protected function scriptable, only from the context of this function call:
                        QScriptValue proto = engine->defaultPrototype(qMetaTypeId<RGraphicsViewWorker*>());
                        REcmaHelper::registerFunction(engine, &proto, drawPlus, "drawPlus");
                        
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RGraphicsViewWorker *, copyable: false
        << qScriptValueFromValue(engine, 

        worker
        )
      



    // type: QPointF, copyable: false
        << qScriptValueFromValue(engine, 

        pt
        )
      



    // type: double, copyable: true
        << qScriptValueFromValue(engine, 

        pSize
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::drawPlus", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::drawEx(
                RGraphicsViewWorker * worker, QPointF pt, double pSize
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::drawEx", engine);
                QScriptValue _q_function = __qtscript_self.property("drawEx");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=3*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::drawEx";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::drawEx(
                            worker, pt, pSize
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::drawEx", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                        // temporary make protected function scriptable, only from the context of this function call:
                        QScriptValue proto = engine->defaultPrototype(qMetaTypeId<RGraphicsViewWorker*>());
                        REcmaHelper::registerFunction(engine, &proto, drawEx, "drawEx");
                        
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RGraphicsViewWorker *, copyable: false
        << qScriptValueFromValue(engine, 

        worker
        )
      



    // type: QPointF, copyable: false
        << qScriptValueFromValue(engine, 

        pt
        )
      



    // type: double, copyable: true
        << qScriptValueFromValue(engine, 

        pSize
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::drawEx", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::drawVBar(
                RGraphicsViewWorker * worker, QPointF pt, double pSize
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::drawVBar", engine);
                QScriptValue _q_function = __qtscript_self.property("drawVBar");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=3*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::drawVBar";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::drawVBar(
                            worker, pt, pSize
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::drawVBar", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                        // temporary make protected function scriptable, only from the context of this function call:
                        QScriptValue proto = engine->defaultPrototype(qMetaTypeId<RGraphicsViewWorker*>());
                        REcmaHelper::registerFunction(engine, &proto, drawVBar, "drawVBar");
                        
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RGraphicsViewWorker *, copyable: false
        << qScriptValueFromValue(engine, 

        worker
        )
      



    // type: QPointF, copyable: false
        << qScriptValueFromValue(engine, 

        pt
        )
      



    // type: double, copyable: true
        << qScriptValueFromValue(engine, 

        pSize
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::drawVBar", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::drawCircle(
                RGraphicsViewWorker * worker, QPointF pt, double pSize
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::drawCircle", engine);
                QScriptValue _q_function = __qtscript_self.property("drawCircle");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=3*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::drawCircle";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::drawCircle(
                            worker, pt, pSize
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::drawCircle", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                        // temporary make protected function scriptable, only from the context of this function call:
                        QScriptValue proto = engine->defaultPrototype(qMetaTypeId<RGraphicsViewWorker*>());
                        REcmaHelper::registerFunction(engine, &proto, drawCircle, "drawCircle");
                        
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RGraphicsViewWorker *, copyable: false
        << qScriptValueFromValue(engine, 

        worker
        )
      



    // type: QPointF, copyable: false
        << qScriptValueFromValue(engine, 

        pt
        )
      



    // type: double, copyable: true
        << qScriptValueFromValue(engine, 

        pSize
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::drawCircle", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::drawSquare(
                RGraphicsViewWorker * worker, QPointF pt, double pSize
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::drawSquare", engine);
                QScriptValue _q_function = __qtscript_self.property("drawSquare");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=3*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::drawSquare";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::drawSquare(
                            worker, pt, pSize
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::drawSquare", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                        // temporary make protected function scriptable, only from the context of this function call:
                        QScriptValue proto = engine->defaultPrototype(qMetaTypeId<RGraphicsViewWorker*>());
                        REcmaHelper::registerFunction(engine, &proto, drawSquare, "drawSquare");
                        
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RGraphicsViewWorker *, copyable: false
        << qScriptValueFromValue(engine, 

        worker
        )
      



    // type: QPointF, copyable: false
        << qScriptValueFromValue(engine, 

        pt
        )
      



    // type: double, copyable: true
        << qScriptValueFromValue(engine, 

        pSize
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::drawSquare", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::paintOrigin(
                RGraphicsViewWorker * worker
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::paintOrigin", engine);
                QScriptValue _q_function = __qtscript_self.property("paintOrigin");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::paintOrigin";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::paintOrigin(
                            worker
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::paintOrigin", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                        // temporary make protected function scriptable, only from the context of this function call:
                        QScriptValue proto = engine->defaultPrototype(qMetaTypeId<RGraphicsViewWorker*>());
                        REcmaHelper::registerFunction(engine, &proto, paintOrigin, "paintOrigin");
                        
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RGraphicsViewWorker *, copyable: false
        << qScriptValueFromValue(engine, 

        worker
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::paintOrigin", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::paintReferencePoint(
                RGraphicsViewWorker * worker, const RRefPoint & pos, bool highlight
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::paintReferencePoint", engine);
                QScriptValue _q_function = __qtscript_self.property("paintReferencePoint");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=3*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::paintReferencePoint";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::paintReferencePoint(
                            worker, pos, highlight
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::paintReferencePoint", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                        // temporary make protected function scriptable, only from the context of this function call:
                        QScriptValue proto = engine->defaultPrototype(qMetaTypeId<RGraphicsViewWorker*>());
                        REcmaHelper::registerFunction(engine, &proto, paintReferencePoint, "paintReferencePoint");
                        
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RGraphicsViewWorker *, copyable: false
        << qScriptValueFromValue(engine, 

        worker
        )
      



    // type: RRefPoint &, copyable: true
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new RRefPoint(pos)
        )
      



    // type: bool, copyable: true
        << qScriptValueFromValue(engine, 

        highlight
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::paintReferencePoint", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::paintCursor(
                RGraphicsViewWorker * worker
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::paintCursor", engine);
                QScriptValue _q_function = __qtscript_self.property("paintCursor");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::paintCursor";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::paintCursor(
                            worker
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::paintCursor", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                        // temporary make protected function scriptable, only from the context of this function call:
                        QScriptValue proto = engine->defaultPrototype(qMetaTypeId<RGraphicsViewWorker*>());
                        REcmaHelper::registerFunction(engine, &proto, paintCursor, "paintCursor");
                        
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RGraphicsViewWorker *, copyable: false
        << qScriptValueFromValue(engine, 

        worker
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::paintCursor", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::paintRelativeZero(
                RGraphicsViewWorker * worker
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::paintRelativeZero", engine);
                QScriptValue _q_function = __qtscript_self.property("paintRelativeZero");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::paintRelativeZero";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::paintRelativeZero(
                            worker
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::paintRelativeZero", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                        // temporary make protected function scriptable, only from the context of this function call:
                        QScriptValue proto = engine->defaultPrototype(qMetaTypeId<RGraphicsViewWorker*>());
                        REcmaHelper::registerFunction(engine, &proto, paintRelativeZero, "paintRelativeZero");
                        
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RGraphicsViewWorker *, copyable: false
        << qScriptValueFromValue(engine, 

        worker
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::paintRelativeZero", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::endPaint(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::endPaint", engine);
                QScriptValue _q_function = __qtscript_self.property("endPaint");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::endPaint";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::endPaint(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::endPaint", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                        // temporary make protected function scriptable, only from the context of this function call:
                        QScriptValue proto = engine->defaultPrototype(qMetaTypeId<RGraphicsViewWorker*>());
                        REcmaHelper::registerFunction(engine, &proto, endPaint, "endPaint");
                        
                            _q_function.call(__qtscript_self)
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::endPaint", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::invalidate(
                bool force
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::invalidate", engine);
                QScriptValue _q_function = __qtscript_self.property("invalidate");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::invalidate";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::invalidate(
                            force
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::invalidate", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                        // temporary make protected function scriptable, only from the context of this function call:
                        QScriptValue proto = engine->defaultPrototype(qMetaTypeId<RGraphicsViewWorker*>());
                        REcmaHelper::registerFunction(engine, &proto, invalidate, "invalidate");
                        
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: bool, copyable: true
        << qScriptValueFromValue(engine, 

        force
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::invalidate", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::initWorkers(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::initWorkers", engine);
                QScriptValue _q_function = __qtscript_self.property("initWorkers");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::initWorkers";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::initWorkers(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::initWorkers", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                        // temporary make protected function scriptable, only from the context of this function call:
                        QScriptValue proto = engine->defaultPrototype(qMetaTypeId<RGraphicsViewWorker*>());
                        REcmaHelper::registerFunction(engine, &proto, initWorkers, "initWorkers");
                        
                            _q_function.call(__qtscript_self)
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::initWorkers", engine);

                    
            }
        
    
    
      void REcmaShellGraphicsViewWorker::updateTransformation(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::updateTransformation", engine);
                QScriptValue _q_function = __qtscript_self.property("updateTransformation");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::updateTransformation";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::updateTransformation(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::updateTransformation", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                        // temporary make protected function scriptable, only from the context of this function call:
                        QScriptValue proto = engine->defaultPrototype(qMetaTypeId<RGraphicsViewWorker*>());
                        REcmaHelper::registerFunction(engine, &proto, updateTransformation, "updateTransformation");
                        
                            _q_function.call(__qtscript_self)
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::updateTransformation", engine);

                    
            }
        
    
  
        // methods of 1st level base class RGraphicsView:
        
      void REcmaShellGraphicsViewWorker::setViewportNumber(
                int n
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setViewportNumber", engine);
                QScriptValue _q_function = __qtscript_self.property("setViewportNumber");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setViewportNumber";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setViewportNumber(
                            n
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setViewportNumber", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: int, copyable: true
        << qScriptValueFromValue(engine, 

        n
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setViewportNumber", engine);

                    
            }
        
    
      int REcmaShellGraphicsViewWorker::getViewportNumber(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getViewportNumber", engine);
                QScriptValue _q_function = __qtscript_self.property("getViewportNumber");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getViewportNumber";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        int ret =
                        RGraphicsViewWorker::getViewportNumber(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getViewportNumber", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    int res;
                      
                          res = qscriptvalue_cast< 
                            int
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getViewportNumber", engine);

                    
                            return res;
                          
            }
        
    
      void REcmaShellGraphicsViewWorker::clear(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::clear", engine);
                QScriptValue _q_function = __qtscript_self.property("clear");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::clear";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::clear(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::clear", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self)
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::clear", engine);

                    
            }
        
    
      void REcmaShellGraphicsViewWorker::clearCaches(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::clearCaches", engine);
                QScriptValue _q_function = __qtscript_self.property("clearCaches");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::clearCaches";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::clearCaches(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::clearCaches", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self)
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::clearCaches", engine);

                    
            }
        
    
      void REcmaShellGraphicsViewWorker::setDisplayOnlyCurrentUcs(
                bool on
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setDisplayOnlyCurrentUcs", engine);
                QScriptValue _q_function = __qtscript_self.property("setDisplayOnlyCurrentUcs");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setDisplayOnlyCurrentUcs";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setDisplayOnlyCurrentUcs(
                            on
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setDisplayOnlyCurrentUcs", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: bool, copyable: true
        << qScriptValueFromValue(engine, 

        on
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setDisplayOnlyCurrentUcs", engine);

                    
            }
        
    
      void REcmaShellGraphicsViewWorker::setScene(
                RGraphicsScene * scene, bool regen
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setScene", engine);
                QScriptValue _q_function = __qtscript_self.property("setScene");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=2*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setScene";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setScene(
                            scene, regen
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setScene", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RGraphicsScene *, copyable: false
        << qScriptValueFromValue(engine, 

        scene
        )
      



    // type: bool, copyable: true
        << qScriptValueFromValue(engine, 

        regen
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setScene", engine);

                    
            }
        
    
      RGraphicsScene * REcmaShellGraphicsViewWorker::getScene(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getScene", engine);
                QScriptValue _q_function = __qtscript_self.property("getScene");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getScene";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsScene * ret =
                        RGraphicsViewWorker::getScene(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getScene", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    RGraphicsScene * res;
                      
                          res = qscriptvalue_cast< 
                            RGraphicsScene *
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getScene", engine);

                    
                            return res;
                          
            }
        
    
      RDocument * REcmaShellGraphicsViewWorker::getDocument(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getDocument", engine);
                QScriptValue _q_function = __qtscript_self.property("getDocument");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getDocument";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RDocument * ret =
                        RGraphicsViewWorker::getDocument(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getDocument", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    RDocument * res;
                      
                          res = qscriptvalue_cast< 
                            RDocument *
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getDocument", engine);

                    
                            return res;
                          
            }
        
    
      RDocumentInterface * REcmaShellGraphicsViewWorker::getDocumentInterface(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getDocumentInterface", engine);
                QScriptValue _q_function = __qtscript_self.property("getDocumentInterface");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getDocumentInterface";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RDocumentInterface * ret =
                        RGraphicsViewWorker::getDocumentInterface(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getDocumentInterface", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    RDocumentInterface * res;
                      
                          res = qscriptvalue_cast< 
                            RDocumentInterface *
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getDocumentInterface", engine);

                    
                            return res;
                          
            }
        
    
      RVector REcmaShellGraphicsViewWorker::mapFromView(
                const RVector & v, double z
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::mapFromView", engine);
                QScriptValue _q_function = __qtscript_self.property("mapFromView");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=2*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::mapFromView";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RVector ret =
                        RGraphicsViewWorker::mapFromView(
                            v, z
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::mapFromView", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    RVector res;
                      
                          res = qscriptvalue_cast< 
                            RVector
                          >(
                        
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RVector &, copyable: true
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new RVector(v)
        )
      



    // type: double, copyable: true
        << qScriptValueFromValue(engine, 

        z
        )
      
                            )
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::mapFromView", engine);

                    
                            return res;
                          
            }
        
    
      RVector REcmaShellGraphicsViewWorker::mapToView(
                const RVector & v
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::mapToView", engine);
                QScriptValue _q_function = __qtscript_self.property("mapToView");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::mapToView";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RVector ret =
                        RGraphicsViewWorker::mapToView(
                            v
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::mapToView", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    RVector res;
                      
                          res = qscriptvalue_cast< 
                            RVector
                          >(
                        
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RVector &, copyable: true
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new RVector(v)
        )
      
                            )
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::mapToView", engine);

                    
                            return res;
                          
            }
        
      RBox REcmaShellGraphicsViewWorker::mapToView(
                const RBox & box
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::mapToView", engine);
                QScriptValue _q_function = __qtscript_self.property("mapToView");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::mapToView";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RBox ret =
                        RGraphicsViewWorker::mapToView(
                            box
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::mapToView", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    RBox res;
                      
                          res = qscriptvalue_cast< 
                            RBox
                          >(
                        
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RBox &, copyable: true
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new RBox(box)
        )
      
                            )
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::mapToView", engine);

                    
                            return res;
                          
            }
        
    
      double REcmaShellGraphicsViewWorker::mapDistanceFromView(
                double d
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::mapDistanceFromView", engine);
                QScriptValue _q_function = __qtscript_self.property("mapDistanceFromView");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::mapDistanceFromView";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        double ret =
                        RGraphicsViewWorker::mapDistanceFromView(
                            d
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::mapDistanceFromView", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    double res;
                      
                          res = qscriptvalue_cast< 
                            double
                          >(
                        
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: double, copyable: true
        << qScriptValueFromValue(engine, 

        d
        )
      
                            )
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::mapDistanceFromView", engine);

                    
                            return res;
                          
            }
        
    
      double REcmaShellGraphicsViewWorker::mapDistanceToView(
                double d
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::mapDistanceToView", engine);
                QScriptValue _q_function = __qtscript_self.property("mapDistanceToView");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::mapDistanceToView";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        double ret =
                        RGraphicsViewWorker::mapDistanceToView(
                            d
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::mapDistanceToView", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    double res;
                      
                          res = qscriptvalue_cast< 
                            double
                          >(
                        
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: double, copyable: true
        << qScriptValueFromValue(engine, 

        d
        )
      
                            )
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::mapDistanceToView", engine);

                    
                            return res;
                          
            }
        
    
      QList < RVector > REcmaShellGraphicsViewWorker::mapCornersFromView(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::mapCornersFromView", engine);
                QScriptValue _q_function = __qtscript_self.property("mapCornersFromView");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::mapCornersFromView";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        QList < RVector > ret =
                        RGraphicsViewWorker::mapCornersFromView(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::mapCornersFromView", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    QList < RVector > res;
                      
                          REcmaHelper::fromScriptValue(engine, 
                        
                            _q_function.call(__qtscript_self)
                        
                      , res
                    
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::mapCornersFromView", engine);

                    
                            return res;
                          
            }
        
    
      RBox REcmaShellGraphicsViewWorker::getBox(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getBox", engine);
                QScriptValue _q_function = __qtscript_self.property("getBox");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getBox";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RBox ret =
                        RGraphicsViewWorker::getBox(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getBox", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    RBox res;
                      
                          res = qscriptvalue_cast< 
                            RBox
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getBox", engine);

                    
                            return res;
                          
            }
        
    
      RVector REcmaShellGraphicsViewWorker::getMinimum(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getMinimum", engine);
                QScriptValue _q_function = __qtscript_self.property("getMinimum");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getMinimum";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RVector ret =
                        RGraphicsViewWorker::getMinimum(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getMinimum", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    RVector res;
                      
                          res = qscriptvalue_cast< 
                            RVector
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getMinimum", engine);

                    
                            return res;
                          
            }
        
    
      RVector REcmaShellGraphicsViewWorker::getMaximum(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getMaximum", engine);
                QScriptValue _q_function = __qtscript_self.property("getMaximum");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getMaximum";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RVector ret =
                        RGraphicsViewWorker::getMaximum(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getMaximum", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    RVector res;
                      
                          res = qscriptvalue_cast< 
                            RVector
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getMaximum", engine);

                    
                            return res;
                          
            }
        
    
      void REcmaShellGraphicsViewWorker::handleTerminateEvent(
                RTerminateEvent & event
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::handleTerminateEvent", engine);
                QScriptValue _q_function = __qtscript_self.property("handleTerminateEvent");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::handleTerminateEvent";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::handleTerminateEvent(
                            event
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::handleTerminateEvent", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RTerminateEvent &, copyable: false
        << qScriptValueFromValue(engine, 

        &event
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::handleTerminateEvent", engine);

                    
            }
        
    
      void REcmaShellGraphicsViewWorker::handleKeyPressEvent(
                QKeyEvent & event
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::handleKeyPressEvent", engine);
                QScriptValue _q_function = __qtscript_self.property("handleKeyPressEvent");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::handleKeyPressEvent";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::handleKeyPressEvent(
                            event
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::handleKeyPressEvent", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: QKeyEvent &, copyable: false
        << qScriptValueFromValue(engine, 

        &event
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::handleKeyPressEvent", engine);

                    
            }
        
    
      void REcmaShellGraphicsViewWorker::handleKeyReleaseEvent(
                QKeyEvent & event
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::handleKeyReleaseEvent", engine);
                QScriptValue _q_function = __qtscript_self.property("handleKeyReleaseEvent");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::handleKeyReleaseEvent";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::handleKeyReleaseEvent(
                            event
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::handleKeyReleaseEvent", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: QKeyEvent &, copyable: false
        << qScriptValueFromValue(engine, 

        &event
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::handleKeyReleaseEvent", engine);

                    
            }
        
    
      void REcmaShellGraphicsViewWorker::simulateMouseMoveEvent(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::simulateMouseMoveEvent", engine);
                QScriptValue _q_function = __qtscript_self.property("simulateMouseMoveEvent");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::simulateMouseMoveEvent";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::simulateMouseMoveEvent(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::simulateMouseMoveEvent", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self)
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::simulateMouseMoveEvent", engine);

                    
            }
        
    
      void REcmaShellGraphicsViewWorker::handleMouseMoveEvent(
                RMouseEvent & event
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::handleMouseMoveEvent", engine);
                QScriptValue _q_function = __qtscript_self.property("handleMouseMoveEvent");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::handleMouseMoveEvent";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::handleMouseMoveEvent(
                            event
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::handleMouseMoveEvent", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RMouseEvent &, copyable: false
        << qScriptValueFromValue(engine, 

        &event
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::handleMouseMoveEvent", engine);

                    
            }
        
    
      void REcmaShellGraphicsViewWorker::handleMousePressEvent(
                RMouseEvent & event
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::handleMousePressEvent", engine);
                QScriptValue _q_function = __qtscript_self.property("handleMousePressEvent");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::handleMousePressEvent";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::handleMousePressEvent(
                            event
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::handleMousePressEvent", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RMouseEvent &, copyable: false
        << qScriptValueFromValue(engine, 

        &event
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::handleMousePressEvent", engine);

                    
            }
        
    
      void REcmaShellGraphicsViewWorker::handleMouseReleaseEvent(
                RMouseEvent & event
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::handleMouseReleaseEvent", engine);
                QScriptValue _q_function = __qtscript_self.property("handleMouseReleaseEvent");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::handleMouseReleaseEvent";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::handleMouseReleaseEvent(
                            event
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::handleMouseReleaseEvent", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RMouseEvent &, copyable: false
        << qScriptValueFromValue(engine, 

        &event
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::handleMouseReleaseEvent", engine);

                    
            }
        
    
      void REcmaShellGraphicsViewWorker::handleMouseDoubleClickEvent(
                RMouseEvent & event
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::handleMouseDoubleClickEvent", engine);
                QScriptValue _q_function = __qtscript_self.property("handleMouseDoubleClickEvent");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::handleMouseDoubleClickEvent";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::handleMouseDoubleClickEvent(
                            event
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::handleMouseDoubleClickEvent", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RMouseEvent &, copyable: false
        << qScriptValueFromValue(engine, 

        &event
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::handleMouseDoubleClickEvent", engine);

                    
            }
        
    
      void REcmaShellGraphicsViewWorker::handleWheelEvent(
                RWheelEvent & event
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::handleWheelEvent", engine);
                QScriptValue _q_function = __qtscript_self.property("handleWheelEvent");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::handleWheelEvent";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::handleWheelEvent(
                            event
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::handleWheelEvent", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RWheelEvent &, copyable: false
        << qScriptValueFromValue(engine, 

        &event
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::handleWheelEvent", engine);

                    
            }
        
    
      void REcmaShellGraphicsViewWorker::handleTabletEvent(
                RTabletEvent & event
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::handleTabletEvent", engine);
                QScriptValue _q_function = __qtscript_self.property("handleTabletEvent");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::handleTabletEvent";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::handleTabletEvent(
                            event
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::handleTabletEvent", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RTabletEvent &, copyable: false
        << qScriptValueFromValue(engine, 

        &event
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::handleTabletEvent", engine);

                    
            }
        
    
      void REcmaShellGraphicsViewWorker::handleSwipeGestureEvent(
                QSwipeGesture & gesture
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::handleSwipeGestureEvent", engine);
                QScriptValue _q_function = __qtscript_self.property("handleSwipeGestureEvent");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::handleSwipeGestureEvent";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::handleSwipeGestureEvent(
                            gesture
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::handleSwipeGestureEvent", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: QSwipeGesture &, copyable: false
        << qScriptValueFromValue(engine, 

        &gesture
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::handleSwipeGestureEvent", engine);

                    
            }
        
    
      void REcmaShellGraphicsViewWorker::handlePanGestureEvent(
                QPanGesture & gesture
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::handlePanGestureEvent", engine);
                QScriptValue _q_function = __qtscript_self.property("handlePanGestureEvent");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::handlePanGestureEvent";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::handlePanGestureEvent(
                            gesture
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::handlePanGestureEvent", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: QPanGesture &, copyable: false
        << qScriptValueFromValue(engine, 

        &gesture
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::handlePanGestureEvent", engine);

                    
            }
        
    
      void REcmaShellGraphicsViewWorker::handlePinchGestureEvent(
                QPinchGesture & gesture
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::handlePinchGestureEvent", engine);
                QScriptValue _q_function = __qtscript_self.property("handlePinchGestureEvent");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::handlePinchGestureEvent";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::handlePinchGestureEvent(
                            gesture
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::handlePinchGestureEvent", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: QPinchGesture &, copyable: false
        << qScriptValueFromValue(engine, 

        &gesture
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::handlePinchGestureEvent", engine);

                    
            }
        
    
      void REcmaShellGraphicsViewWorker::giveFocus(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::giveFocus", engine);
                QScriptValue _q_function = __qtscript_self.property("giveFocus");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::giveFocus";
                    
                        qFatal("RGraphicsViewWorker::giveFocus is pure virtual.");
                      
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self)
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::giveFocus", engine);

                    
            }
        
    
      bool REcmaShellGraphicsViewWorker::hasFocus(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::hasFocus", engine);
                QScriptValue _q_function = __qtscript_self.property("hasFocus");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::hasFocus";
                    
                        qFatal("RGraphicsViewWorker::hasFocus is pure virtual.");
                      
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    bool res;
                      
                          res = qscriptvalue_cast< 
                            bool
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::hasFocus", engine);

                    
                            return res;
                          
            }
        
    
      void REcmaShellGraphicsViewWorker::removeFocus(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::removeFocus", engine);
                QScriptValue _q_function = __qtscript_self.property("removeFocus");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::removeFocus";
                    
                        qFatal("RGraphicsViewWorker::removeFocus is pure virtual.");
                      
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self)
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::removeFocus", engine);

                    
            }
        
    
      void REcmaShellGraphicsViewWorker::viewportChangeEvent(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::viewportChangeEvent", engine);
                QScriptValue _q_function = __qtscript_self.property("viewportChangeEvent");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::viewportChangeEvent";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::viewportChangeEvent(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::viewportChangeEvent", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self)
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::viewportChangeEvent", engine);

                    
            }
        
    
      void REcmaShellGraphicsViewWorker::saveViewport(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::saveViewport", engine);
                QScriptValue _q_function = __qtscript_self.property("saveViewport");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::saveViewport";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::saveViewport(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::saveViewport", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self)
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::saveViewport", engine);

                    
            }
        
    
      void REcmaShellGraphicsViewWorker::restoreViewport(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::restoreViewport", engine);
                QScriptValue _q_function = __qtscript_self.property("restoreViewport");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::restoreViewport";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::restoreViewport(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::restoreViewport", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self)
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::restoreViewport", engine);

                    
            }
        
    
      void REcmaShellGraphicsViewWorker::zoomIn(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::zoomIn", engine);
                QScriptValue _q_function = __qtscript_self.property("zoomIn");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::zoomIn";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::zoomIn(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::zoomIn", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self)
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::zoomIn", engine);

                    
            }
        
      void REcmaShellGraphicsViewWorker::zoomIn(
                const RVector & center, double factor
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::zoomIn", engine);
                QScriptValue _q_function = __qtscript_self.property("zoomIn");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=2*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::zoomIn";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::zoomIn(
                            center, factor
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::zoomIn", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RVector &, copyable: true
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new RVector(center)
        )
      



    // type: double, copyable: true
        << qScriptValueFromValue(engine, 

        factor
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::zoomIn", engine);

                    
            }
        
    
      void REcmaShellGraphicsViewWorker::zoomOut(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::zoomOut", engine);
                QScriptValue _q_function = __qtscript_self.property("zoomOut");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::zoomOut";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::zoomOut(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::zoomOut", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self)
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::zoomOut", engine);

                    
            }
        
      void REcmaShellGraphicsViewWorker::zoomOut(
                const RVector & center, double factor
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::zoomOut", engine);
                QScriptValue _q_function = __qtscript_self.property("zoomOut");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=2*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::zoomOut";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::zoomOut(
                            center, factor
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::zoomOut", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RVector &, copyable: true
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new RVector(center)
        )
      



    // type: double, copyable: true
        << qScriptValueFromValue(engine, 

        factor
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::zoomOut", engine);

                    
            }
        
    
      void REcmaShellGraphicsViewWorker::zoom(
                const RVector & center, double factor
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::zoom", engine);
                QScriptValue _q_function = __qtscript_self.property("zoom");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=2*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::zoom";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::zoom(
                            center, factor
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::zoom", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RVector &, copyable: true
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new RVector(center)
        )
      



    // type: double, copyable: true
        << qScriptValueFromValue(engine, 

        factor
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::zoom", engine);

                    
            }
        
    
      void REcmaShellGraphicsViewWorker::zoomTo(
                const RBox & window, int margin
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::zoomTo", engine);
                QScriptValue _q_function = __qtscript_self.property("zoomTo");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=2*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::zoomTo";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::zoomTo(
                            window, margin
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::zoomTo", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RBox &, copyable: true
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new RBox(window)
        )
      



    // type: int, copyable: true
        << qScriptValueFromValue(engine, 

        margin
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::zoomTo", engine);

                    
            }
        
    
      void REcmaShellGraphicsViewWorker::zoomPrevious(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::zoomPrevious", engine);
                QScriptValue _q_function = __qtscript_self.property("zoomPrevious");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::zoomPrevious";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::zoomPrevious(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::zoomPrevious", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self)
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::zoomPrevious", engine);

                    
            }
        
    
      void REcmaShellGraphicsViewWorker::autoZoom(
                int margin, bool ignoreEmpty, bool ignoreLineweight
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::autoZoom", engine);
                QScriptValue _q_function = __qtscript_self.property("autoZoom");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=3*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::autoZoom";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::autoZoom(
                            margin, ignoreEmpty, ignoreLineweight
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::autoZoom", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: int, copyable: true
        << qScriptValueFromValue(engine, 

        margin
        )
      



    // type: bool, copyable: true
        << qScriptValueFromValue(engine, 

        ignoreEmpty
        )
      



    // type: bool, copyable: true
        << qScriptValueFromValue(engine, 

        ignoreLineweight
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::autoZoom", engine);

                    
            }
        
    
      bool REcmaShellGraphicsViewWorker::zoomToSelection(
                int margin
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::zoomToSelection", engine);
                QScriptValue _q_function = __qtscript_self.property("zoomToSelection");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::zoomToSelection";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        bool ret =
                        RGraphicsViewWorker::zoomToSelection(
                            margin
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::zoomToSelection", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    bool res;
                      
                          res = qscriptvalue_cast< 
                            bool
                          >(
                        
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: int, copyable: true
        << qScriptValueFromValue(engine, 

        margin
        )
      
                            )
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::zoomToSelection", engine);

                    
                            return res;
                          
            }
        
    
      bool REcmaShellGraphicsViewWorker::zoomToEntities(
                const QSet < REntity::Id > & ids, int margin
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::zoomToEntities", engine);
                QScriptValue _q_function = __qtscript_self.property("zoomToEntities");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=2*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::zoomToEntities";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        bool ret =
                        RGraphicsViewWorker::zoomToEntities(
                            ids, margin
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::zoomToEntities", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    bool res;
                      
                          res = qscriptvalue_cast< 
                            bool
                          >(
                        
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: QSet < REntity::Id > &, copyable: false
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new QSet < REntity::Id >(ids)
        )
      



    // type: int, copyable: true
        << qScriptValueFromValue(engine, 

        margin
        )
      
                            )
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::zoomToEntities", engine);

                    
                            return res;
                          
            }
        
    
      void REcmaShellGraphicsViewWorker::centerToPoint(
                const RVector & point
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::centerToPoint", engine);
                QScriptValue _q_function = __qtscript_self.property("centerToPoint");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::centerToPoint";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::centerToPoint(
                            point
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::centerToPoint", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RVector &, copyable: true
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new RVector(point)
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::centerToPoint", engine);

                    
            }
        
    
      void REcmaShellGraphicsViewWorker::centerToBox(
                const RBox & box
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::centerToBox", engine);
                QScriptValue _q_function = __qtscript_self.property("centerToBox");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::centerToBox";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::centerToBox(
                            box
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::centerToBox", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RBox &, copyable: true
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new RBox(box)
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::centerToBox", engine);

                    
            }
        
    
      void REcmaShellGraphicsViewWorker::pan(
                const RVector & delta, bool regen
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::pan", engine);
                QScriptValue _q_function = __qtscript_self.property("pan");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=2*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::pan";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::pan(
                            delta, regen
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::pan", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RVector &, copyable: true
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new RVector(delta)
        )
      



    // type: bool, copyable: true
        << qScriptValueFromValue(engine, 

        regen
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::pan", engine);

                    
            }
        
    
      void REcmaShellGraphicsViewWorker::startPan(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::startPan", engine);
                QScriptValue _q_function = __qtscript_self.property("startPan");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::startPan";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::startPan(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::startPan", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self)
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::startPan", engine);

                    
            }
        
    
      double REcmaShellGraphicsViewWorker::getFactor(
                bool includeStepFactor
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getFactor", engine);
                QScriptValue _q_function = __qtscript_self.property("getFactor");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getFactor";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        double ret =
                        RGraphicsViewWorker::getFactor(
                            includeStepFactor
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getFactor", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    double res;
                      
                          res = qscriptvalue_cast< 
                            double
                          >(
                        
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: bool, copyable: true
        << qScriptValueFromValue(engine, 

        includeStepFactor
        )
      
                            )
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getFactor", engine);

                    
                            return res;
                          
            }
        
    
      void REcmaShellGraphicsViewWorker::setFactor(
                double f, bool regen
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setFactor", engine);
                QScriptValue _q_function = __qtscript_self.property("setFactor");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=2*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setFactor";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setFactor(
                            f, regen
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setFactor", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: double, copyable: true
        << qScriptValueFromValue(engine, 

        f
        )
      



    // type: bool, copyable: true
        << qScriptValueFromValue(engine, 

        regen
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setFactor", engine);

                    
            }
        
    
      RVector REcmaShellGraphicsViewWorker::getOffset(
                bool includeStepOffset
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getOffset", engine);
                QScriptValue _q_function = __qtscript_self.property("getOffset");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getOffset";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RVector ret =
                        RGraphicsViewWorker::getOffset(
                            includeStepOffset
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getOffset", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    RVector res;
                      
                          res = qscriptvalue_cast< 
                            RVector
                          >(
                        
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: bool, copyable: true
        << qScriptValueFromValue(engine, 

        includeStepOffset
        )
      
                            )
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getOffset", engine);

                    
                            return res;
                          
            }
        
    
      void REcmaShellGraphicsViewWorker::setOffset(
                const RVector & offset, bool regen
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setOffset", engine);
                QScriptValue _q_function = __qtscript_self.property("setOffset");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=2*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setOffset";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setOffset(
                            offset, regen
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setOffset", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RVector &, copyable: true
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new RVector(offset)
        )
      



    // type: bool, copyable: true
        << qScriptValueFromValue(engine, 

        regen
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setOffset", engine);

                    
            }
        
    
      void REcmaShellGraphicsViewWorker::regenerate(
                QSet < REntity::Id > & affectedEntities
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::regenerate", engine);
                QScriptValue _q_function = __qtscript_self.property("regenerate");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::regenerate";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::regenerate(
                            affectedEntities
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::regenerate", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: QSet < REntity::Id > &, copyable: false
        << qScriptValueFromValue(engine, 

        &affectedEntities
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::regenerate", engine);

                    
            }
        
      void REcmaShellGraphicsViewWorker::regenerate(
                bool force
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::regenerate", engine);
                QScriptValue _q_function = __qtscript_self.property("regenerate");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::regenerate";
                    
                        qFatal("RGraphicsViewWorker::regenerate is pure virtual.");
                      
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: bool, copyable: true
        << qScriptValueFromValue(engine, 

        force
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::regenerate", engine);

                    
            }
        
    
      void REcmaShellGraphicsViewWorker::repaintView(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::repaintView", engine);
                QScriptValue _q_function = __qtscript_self.property("repaintView");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::repaintView";
                    
                        qFatal("RGraphicsViewWorker::repaintView is pure virtual.");
                      
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self)
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::repaintView", engine);

                    
            }
        
    
      int REcmaShellGraphicsViewWorker::getWidth(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getWidth", engine);
                QScriptValue _q_function = __qtscript_self.property("getWidth");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getWidth";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        int ret =
                        RGraphicsViewWorker::getWidth(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getWidth", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    int res;
                      
                          res = qscriptvalue_cast< 
                            int
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getWidth", engine);

                    
                            return res;
                          
            }
        
    
      int REcmaShellGraphicsViewWorker::getHeight(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getHeight", engine);
                QScriptValue _q_function = __qtscript_self.property("getHeight");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getHeight";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        int ret =
                        RGraphicsViewWorker::getHeight(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getHeight", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    int res;
                      
                          res = qscriptvalue_cast< 
                            int
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getHeight", engine);

                    
                            return res;
                          
            }
        
    
      int REcmaShellGraphicsViewWorker::isActive(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::isActive", engine);
                QScriptValue _q_function = __qtscript_self.property("isActive");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::isActive";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        int ret =
                        RGraphicsViewWorker::isActive(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::isActive", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    int res;
                      
                          res = qscriptvalue_cast< 
                            int
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::isActive", engine);

                    
                            return res;
                          
            }
        
    
      bool REcmaShellGraphicsViewWorker::getSignalsBlocked(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getSignalsBlocked", engine);
                QScriptValue _q_function = __qtscript_self.property("getSignalsBlocked");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getSignalsBlocked";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        bool ret =
                        RGraphicsViewWorker::getSignalsBlocked(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getSignalsBlocked", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    bool res;
                      
                          res = qscriptvalue_cast< 
                            bool
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getSignalsBlocked", engine);

                    
                            return res;
                          
            }
        
    
      void REcmaShellGraphicsViewWorker::setSignalsBlocked(
                bool on
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setSignalsBlocked", engine);
                QScriptValue _q_function = __qtscript_self.property("setSignalsBlocked");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setSignalsBlocked";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setSignalsBlocked(
                            on
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setSignalsBlocked", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: bool, copyable: true
        << qScriptValueFromValue(engine, 

        on
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setSignalsBlocked", engine);

                    
            }
        
    
      void REcmaShellGraphicsViewWorker::setNavigationAction(
                RAction * action
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setNavigationAction", engine);
                QScriptValue _q_function = __qtscript_self.property("setNavigationAction");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setNavigationAction";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setNavigationAction(
                            action
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setNavigationAction", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RAction *, copyable: false
        << qScriptValueFromValue(engine, 

        action
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setNavigationAction", engine);

                    
            }
        
    
      RGrid * REcmaShellGraphicsViewWorker::getGrid(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getGrid", engine);
                QScriptValue _q_function = __qtscript_self.property("getGrid");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getGrid";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGrid * ret =
                        RGraphicsViewWorker::getGrid(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getGrid", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    RGrid * res;
                      
                          res = qscriptvalue_cast< 
                            RGrid *
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getGrid", engine);

                    
                            return res;
                          
            }
        
    
      void REcmaShellGraphicsViewWorker::setGrid(
                RGrid * g
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setGrid", engine);
                QScriptValue _q_function = __qtscript_self.property("setGrid");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setGrid";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setGrid(
                            g
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setGrid", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RGrid *, copyable: false
        << qScriptValueFromValue(engine, 

        g
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setGrid", engine);

                    
            }
        
    
      void REcmaShellGraphicsViewWorker::setGridVisible(
                bool on
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setGridVisible", engine);
                QScriptValue _q_function = __qtscript_self.property("setGridVisible");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setGridVisible";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setGridVisible(
                            on
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setGridVisible", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: bool, copyable: true
        << qScriptValueFromValue(engine, 

        on
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setGridVisible", engine);

                    
            }
        
    
      bool REcmaShellGraphicsViewWorker::isGridVisible(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::isGridVisible", engine);
                QScriptValue _q_function = __qtscript_self.property("isGridVisible");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::isGridVisible";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        bool ret =
                        RGraphicsViewWorker::isGridVisible(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::isGridVisible", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    bool res;
                      
                          res = qscriptvalue_cast< 
                            bool
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::isGridVisible", engine);

                    
                            return res;
                          
            }
        
    
      void REcmaShellGraphicsViewWorker::paintGridPoints(
                const QVector < double > & ucsPositionX, const QVector < double > & ucsPositionY
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::paintGridPoints", engine);
                QScriptValue _q_function = __qtscript_self.property("paintGridPoints");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=2*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::paintGridPoints";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::paintGridPoints(
                            ucsPositionX, ucsPositionY
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::paintGridPoints", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: QVector < double > &, copyable: false
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new QVector < double >(ucsPositionX)
        )
      



    // type: QVector < double > &, copyable: false
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new QVector < double >(ucsPositionY)
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::paintGridPoints", engine);

                    
            }
        
    
      void REcmaShellGraphicsViewWorker::paintGridPoint(
                const RVector & arg1
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::paintGridPoint", engine);
                QScriptValue _q_function = __qtscript_self.property("paintGridPoint");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::paintGridPoint";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::paintGridPoint(
                            arg1
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::paintGridPoint", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RVector &, copyable: true
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new RVector(arg1)
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::paintGridPoint", engine);

                    
            }
        
    
      void REcmaShellGraphicsViewWorker::paintGridLine(
                const RLine & arg1
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::paintGridLine", engine);
                QScriptValue _q_function = __qtscript_self.property("paintGridLine");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::paintGridLine";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::paintGridLine(
                            arg1
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::paintGridLine", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RLine &, copyable: true
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new RLine(arg1)
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::paintGridLine", engine);

                    
            }
        
    
      void REcmaShellGraphicsViewWorker::paintCursorLine(
                const RLine & arg1
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::paintCursorLine", engine);
                QScriptValue _q_function = __qtscript_self.property("paintCursorLine");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::paintCursorLine";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::paintCursorLine(
                            arg1
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::paintCursorLine", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RLine &, copyable: true
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new RLine(arg1)
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::paintCursorLine", engine);

                    
            }
        
    
      QCursor REcmaShellGraphicsViewWorker::getCursor(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getCursor", engine);
                QScriptValue _q_function = __qtscript_self.property("getCursor");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getCursor";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        QCursor ret =
                        RGraphicsViewWorker::getCursor(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getCursor", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    QCursor res;
                      
                          res = qscriptvalue_cast< 
                            QCursor
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getCursor", engine);

                    
                            return res;
                          
            }
        
    
      void REcmaShellGraphicsViewWorker::setCursor(
                Qt::CursorShape arg1
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setCursor", engine);
                QScriptValue _q_function = __qtscript_self.property("setCursor");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setCursor";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setCursor(
                            arg1
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setCursor", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: Qt::CursorShape, copyable: true
        << qScriptValueFromValue(engine, 

        arg1
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setCursor", engine);

                    
            }
        
      void REcmaShellGraphicsViewWorker::setCursor(
                const QCursor & arg1
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setCursor", engine);
                QScriptValue _q_function = __qtscript_self.property("setCursor");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setCursor";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setCursor(
                            arg1
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setCursor", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: QCursor &, copyable: false
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new QCursor(arg1)
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setCursor", engine);

                    
            }
        
    
      RRefPoint REcmaShellGraphicsViewWorker::getClosestReferencePoint(
                const RVector & screenPosition, int range
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getClosestReferencePoint", engine);
                QScriptValue _q_function = __qtscript_self.property("getClosestReferencePoint");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=2*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getClosestReferencePoint";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RRefPoint ret =
                        RGraphicsViewWorker::getClosestReferencePoint(
                            screenPosition, range
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getClosestReferencePoint", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    RRefPoint res;
                      
                          res = qscriptvalue_cast< 
                            RRefPoint
                          >(
                        
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RVector &, copyable: true
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new RVector(screenPosition)
        )
      



    // type: int, copyable: true
        << qScriptValueFromValue(engine, 

        range
        )
      
                            )
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getClosestReferencePoint", engine);

                    
                            return res;
                          
            }
        
      RRefPoint REcmaShellGraphicsViewWorker::getClosestReferencePoint(
                REntity::Id entityId, const RVector & screenPosition
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getClosestReferencePoint", engine);
                QScriptValue _q_function = __qtscript_self.property("getClosestReferencePoint");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=2*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getClosestReferencePoint";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RRefPoint ret =
                        RGraphicsViewWorker::getClosestReferencePoint(
                            entityId, screenPosition
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getClosestReferencePoint", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    RRefPoint res;
                      
                          res = qscriptvalue_cast< 
                            RRefPoint
                          >(
                        
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: REntity::Id, copyable: true
        << qScriptValueFromValue(engine, 

        entityId
        )
      



    // type: RVector &, copyable: true
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new RVector(screenPosition)
        )
      
                            )
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getClosestReferencePoint", engine);

                    
                            return res;
                          
            }
        
    
      REntity::Id REcmaShellGraphicsViewWorker::getClosestEntity(
                const RVector & screenPosition, int range, int strictRange, bool includeLockedLayers, bool selectedOnly
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getClosestEntity", engine);
                QScriptValue _q_function = __qtscript_self.property("getClosestEntity");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=5*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getClosestEntity";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        REntity::Id ret =
                        RGraphicsViewWorker::getClosestEntity(
                            screenPosition, range, strictRange, includeLockedLayers, selectedOnly
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getClosestEntity", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    REntity::Id res;
                      
                          res = qscriptvalue_cast< 
                            REntity::Id
                          >(
                        
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RVector &, copyable: true
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new RVector(screenPosition)
        )
      



    // type: int, copyable: true
        << qScriptValueFromValue(engine, 

        range
        )
      



    // type: int, copyable: true
        << qScriptValueFromValue(engine, 

        strictRange
        )
      



    // type: bool, copyable: true
        << qScriptValueFromValue(engine, 

        includeLockedLayers
        )
      



    // type: bool, copyable: true
        << qScriptValueFromValue(engine, 

        selectedOnly
        )
      
                            )
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getClosestEntity", engine);

                    
                            return res;
                          
            }
        
    
      void REcmaShellGraphicsViewWorker::setBackgroundColor(
                const QColor & col
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setBackgroundColor", engine);
                QScriptValue _q_function = __qtscript_self.property("setBackgroundColor");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setBackgroundColor";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setBackgroundColor(
                            col
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setBackgroundColor", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: QColor &, copyable: true
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new QColor(col)
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setBackgroundColor", engine);

                    
            }
        
    
      QColor REcmaShellGraphicsViewWorker::getBackgroundColor(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getBackgroundColor", engine);
                QScriptValue _q_function = __qtscript_self.property("getBackgroundColor");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getBackgroundColor";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        QColor ret =
                        RGraphicsViewWorker::getBackgroundColor(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getBackgroundColor", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    QColor res;
                      
                          res = qscriptvalue_cast< 
                            QColor
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getBackgroundColor", engine);

                    
                            return res;
                          
            }
        
    
      int REcmaShellGraphicsViewWorker::getMargin(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getMargin", engine);
                QScriptValue _q_function = __qtscript_self.property("getMargin");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getMargin";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        int ret =
                        RGraphicsViewWorker::getMargin(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getMargin", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    int res;
                      
                          res = qscriptvalue_cast< 
                            int
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getMargin", engine);

                    
                            return res;
                          
            }
        
    
      void REcmaShellGraphicsViewWorker::setMargin(
                int m
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setMargin", engine);
                QScriptValue _q_function = __qtscript_self.property("setMargin");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setMargin";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setMargin(
                            m
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setMargin", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: int, copyable: true
        << qScriptValueFromValue(engine, 

        m
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setMargin", engine);

                    
            }
        
    
      void REcmaShellGraphicsViewWorker::setExporting(
                bool on
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setExporting", engine);
                QScriptValue _q_function = __qtscript_self.property("setExporting");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setExporting";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setExporting(
                            on
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setExporting", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: bool, copyable: true
        << qScriptValueFromValue(engine, 

        on
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setExporting", engine);

                    
            }
        
    
      bool REcmaShellGraphicsViewWorker::isExporting(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::isExporting", engine);
                QScriptValue _q_function = __qtscript_self.property("isExporting");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::isExporting";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        bool ret =
                        RGraphicsViewWorker::isExporting(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::isExporting", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    bool res;
                      
                          res = qscriptvalue_cast< 
                            bool
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::isExporting", engine);

                    
                            return res;
                          
            }
        
    
      bool REcmaShellGraphicsViewWorker::isPrintingOrExporting(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::isPrintingOrExporting", engine);
                QScriptValue _q_function = __qtscript_self.property("isPrintingOrExporting");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::isPrintingOrExporting";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        bool ret =
                        RGraphicsViewWorker::isPrintingOrExporting(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::isPrintingOrExporting", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    bool res;
                      
                          res = qscriptvalue_cast< 
                            bool
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::isPrintingOrExporting", engine);

                    
                            return res;
                          
            }
        
    
      void REcmaShellGraphicsViewWorker::setPrinting(
                bool on
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setPrinting", engine);
                QScriptValue _q_function = __qtscript_self.property("setPrinting");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setPrinting";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setPrinting(
                            on
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setPrinting", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: bool, copyable: true
        << qScriptValueFromValue(engine, 

        on
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setPrinting", engine);

                    
            }
        
    
      bool REcmaShellGraphicsViewWorker::isPrinting(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::isPrinting", engine);
                QScriptValue _q_function = __qtscript_self.property("isPrinting");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::isPrinting";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        bool ret =
                        RGraphicsViewWorker::isPrinting(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::isPrinting", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    bool res;
                      
                          res = qscriptvalue_cast< 
                            bool
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::isPrinting", engine);

                    
                            return res;
                          
            }
        
    
      void REcmaShellGraphicsViewWorker::setPrintPreview(
                bool on
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setPrintPreview", engine);
                QScriptValue _q_function = __qtscript_self.property("setPrintPreview");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setPrintPreview";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setPrintPreview(
                            on
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setPrintPreview", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: bool, copyable: true
        << qScriptValueFromValue(engine, 

        on
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setPrintPreview", engine);

                    
            }
        
    
      bool REcmaShellGraphicsViewWorker::isPrintPreview(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::isPrintPreview", engine);
                QScriptValue _q_function = __qtscript_self.property("isPrintPreview");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::isPrintPreview";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        bool ret =
                        RGraphicsViewWorker::isPrintPreview(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::isPrintPreview", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    bool res;
                      
                          res = qscriptvalue_cast< 
                            bool
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::isPrintPreview", engine);

                    
                            return res;
                          
            }
        
    
      void REcmaShellGraphicsViewWorker::setPrintPointSize(
                const RVector & s
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setPrintPointSize", engine);
                QScriptValue _q_function = __qtscript_self.property("setPrintPointSize");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setPrintPointSize";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setPrintPointSize(
                            s
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setPrintPointSize", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RVector &, copyable: true
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new RVector(s)
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setPrintPointSize", engine);

                    
            }
        
    
      void REcmaShellGraphicsViewWorker::setColorMode(
                RGraphicsView::ColorMode cm
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setColorMode", engine);
                QScriptValue _q_function = __qtscript_self.property("setColorMode");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setColorMode";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setColorMode(
                            cm
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setColorMode", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RGraphicsView::ColorMode, copyable: true
        << qScriptValueFromValue(engine, 

        cm
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setColorMode", engine);

                    
            }
        
    
      RGraphicsView::ColorMode REcmaShellGraphicsViewWorker::getColorMode(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getColorMode", engine);
                QScriptValue _q_function = __qtscript_self.property("getColorMode");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getColorMode";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsView::ColorMode ret =
                        RGraphicsViewWorker::getColorMode(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getColorMode", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    RGraphicsView::ColorMode res;
                      
                          res = qscriptvalue_cast< 
                            RGraphicsView::ColorMode
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getColorMode", engine);

                    
                            return res;
                          
            }
        
    
      void REcmaShellGraphicsViewWorker::setHairlineMode(
                bool on
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setHairlineMode", engine);
                QScriptValue _q_function = __qtscript_self.property("setHairlineMode");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setHairlineMode";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setHairlineMode(
                            on
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setHairlineMode", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: bool, copyable: true
        << qScriptValueFromValue(engine, 

        on
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setHairlineMode", engine);

                    
            }
        
    
      bool REcmaShellGraphicsViewWorker::getHairlineMode(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getHairlineMode", engine);
                QScriptValue _q_function = __qtscript_self.property("getHairlineMode");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getHairlineMode";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        bool ret =
                        RGraphicsViewWorker::getHairlineMode(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getHairlineMode", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    bool res;
                      
                          res = qscriptvalue_cast< 
                            bool
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getHairlineMode", engine);

                    
                            return res;
                          
            }
        
    
      void REcmaShellGraphicsViewWorker::setHairlineMinimumMode(
                bool on
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setHairlineMinimumMode", engine);
                QScriptValue _q_function = __qtscript_self.property("setHairlineMinimumMode");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setHairlineMinimumMode";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setHairlineMinimumMode(
                            on
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setHairlineMinimumMode", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: bool, copyable: true
        << qScriptValueFromValue(engine, 

        on
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setHairlineMinimumMode", engine);

                    
            }
        
    
      bool REcmaShellGraphicsViewWorker::getHairlineMinimumMode(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getHairlineMinimumMode", engine);
                QScriptValue _q_function = __qtscript_self.property("getHairlineMinimumMode");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getHairlineMinimumMode";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        bool ret =
                        RGraphicsViewWorker::getHairlineMinimumMode(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getHairlineMinimumMode", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    bool res;
                      
                          res = qscriptvalue_cast< 
                            bool
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getHairlineMinimumMode", engine);

                    
                            return res;
                          
            }
        
    
      QList < RTextLabel > REcmaShellGraphicsViewWorker::getTextLabels(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getTextLabels", engine);
                QScriptValue _q_function = __qtscript_self.property("getTextLabels");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getTextLabels";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        QList < RTextLabel > ret =
                        RGraphicsViewWorker::getTextLabels(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getTextLabels", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    QList < RTextLabel > res;
                      
                          REcmaHelper::fromScriptValue(engine, 
                        
                            _q_function.call(__qtscript_self)
                        
                      , res
                    
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getTextLabels", engine);

                    
                            return res;
                          
            }
        
    
      void REcmaShellGraphicsViewWorker::clearTextLabels(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::clearTextLabels", engine);
                QScriptValue _q_function = __qtscript_self.property("clearTextLabels");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::clearTextLabels";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::clearTextLabels(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::clearTextLabels", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self)
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::clearTextLabels", engine);

                    
            }
        
    
      void REcmaShellGraphicsViewWorker::addTextLabel(
                const RTextLabel & textLabel
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::addTextLabel", engine);
                QScriptValue _q_function = __qtscript_self.property("addTextLabel");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::addTextLabel";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::addTextLabel(
                            textLabel
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::addTextLabel", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RTextLabel &, copyable: true
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new RTextLabel(textLabel)
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::addTextLabel", engine);

                    
            }
        
    
      RVector REcmaShellGraphicsViewWorker::getLastKnownMousePosition(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getLastKnownMousePosition", engine);
                QScriptValue _q_function = __qtscript_self.property("getLastKnownMousePosition");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getLastKnownMousePosition";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RVector ret =
                        RGraphicsViewWorker::getLastKnownMousePosition(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getLastKnownMousePosition", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    RVector res;
                      
                          res = qscriptvalue_cast< 
                            RVector
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getLastKnownMousePosition", engine);

                    
                            return res;
                          
            }
        
    
      double REcmaShellGraphicsViewWorker::getCurrentStepScaleFactor(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getCurrentStepScaleFactor", engine);
                QScriptValue _q_function = __qtscript_self.property("getCurrentStepScaleFactor");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getCurrentStepScaleFactor";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        double ret =
                        RGraphicsViewWorker::getCurrentStepScaleFactor(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getCurrentStepScaleFactor", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    double res;
                      
                          res = qscriptvalue_cast< 
                            double
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getCurrentStepScaleFactor", engine);

                    
                            return res;
                          
            }
        
    
      void REcmaShellGraphicsViewWorker::setCurrentStepScaleFactor(
                double f
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setCurrentStepScaleFactor", engine);
                QScriptValue _q_function = __qtscript_self.property("setCurrentStepScaleFactor");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setCurrentStepScaleFactor";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setCurrentStepScaleFactor(
                            f
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setCurrentStepScaleFactor", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: double, copyable: true
        << qScriptValueFromValue(engine, 

        f
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setCurrentStepScaleFactor", engine);

                    
            }
        
    
      RVector REcmaShellGraphicsViewWorker::getCurrentStepOffset(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getCurrentStepOffset", engine);
                QScriptValue _q_function = __qtscript_self.property("getCurrentStepOffset");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getCurrentStepOffset";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RVector ret =
                        RGraphicsViewWorker::getCurrentStepOffset(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getCurrentStepOffset", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    RVector res;
                      
                          res = qscriptvalue_cast< 
                            RVector
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getCurrentStepOffset", engine);

                    
                            return res;
                          
            }
        
    
      void REcmaShellGraphicsViewWorker::setCurrentStepOffset(
                const RVector & s
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setCurrentStepOffset", engine);
                QScriptValue _q_function = __qtscript_self.property("setCurrentStepOffset");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setCurrentStepOffset";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setCurrentStepOffset(
                            s
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setCurrentStepOffset", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RVector &, copyable: true
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new RVector(s)
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setCurrentStepOffset", engine);

                    
            }
        
    
      void REcmaShellGraphicsViewWorker::setTextHeightThresholdOverride(
                int v
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setTextHeightThresholdOverride", engine);
                QScriptValue _q_function = __qtscript_self.property("setTextHeightThresholdOverride");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setTextHeightThresholdOverride";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setTextHeightThresholdOverride(
                            v
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setTextHeightThresholdOverride", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: int, copyable: true
        << qScriptValueFromValue(engine, 

        v
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setTextHeightThresholdOverride", engine);

                    
            }
        
    
      int REcmaShellGraphicsViewWorker::getTextHeightThresholdOverride(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getTextHeightThresholdOverride", engine);
                QScriptValue _q_function = __qtscript_self.property("getTextHeightThresholdOverride");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getTextHeightThresholdOverride";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        int ret =
                        RGraphicsViewWorker::getTextHeightThresholdOverride(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getTextHeightThresholdOverride", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    int res;
                      
                          res = qscriptvalue_cast< 
                            int
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getTextHeightThresholdOverride", engine);

                    
                            return res;
                          
            }
        
    
      void REcmaShellGraphicsViewWorker::updateTextHeightThreshold(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::updateTextHeightThreshold", engine);
                QScriptValue _q_function = __qtscript_self.property("updateTextHeightThreshold");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::updateTextHeightThreshold";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::updateTextHeightThreshold(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::updateTextHeightThreshold", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self)
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::updateTextHeightThreshold", engine);

                    
            }
        
    
      bool REcmaShellGraphicsViewWorker::isPathVisible(
                const RPainterPath & path
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::isPathVisible", engine);
                QScriptValue _q_function = __qtscript_self.property("isPathVisible");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::isPathVisible";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        bool ret =
                        RGraphicsViewWorker::isPathVisible(
                            path
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::isPathVisible", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    bool res;
                      
                          res = qscriptvalue_cast< 
                            bool
                          >(
                        
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: RPainterPath &, copyable: true
        << qScriptValueFromValue(engine, 

        
            // const reference argument - make a new object:
            new RPainterPath(path)
        )
      
                            )
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::isPathVisible", engine);

                    
                            return res;
                          
            }
        
    
      void REcmaShellGraphicsViewWorker::setAntialiasing(
                bool val
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setAntialiasing", engine);
                QScriptValue _q_function = __qtscript_self.property("setAntialiasing");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setAntialiasing";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setAntialiasing(
                            val
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setAntialiasing", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: bool, copyable: true
        << qScriptValueFromValue(engine, 

        val
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setAntialiasing", engine);

                    
            }
        
    
      bool REcmaShellGraphicsViewWorker::getAntialiasing(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getAntialiasing", engine);
                QScriptValue _q_function = __qtscript_self.property("getAntialiasing");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getAntialiasing";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        bool ret =
                        RGraphicsViewWorker::getAntialiasing(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getAntialiasing", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    bool res;
                      
                          res = qscriptvalue_cast< 
                            bool
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getAntialiasing", engine);

                    
                            return res;
                          
            }
        
    
      double REcmaShellGraphicsViewWorker::getDevicePixelRatio(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getDevicePixelRatio", engine);
                QScriptValue _q_function = __qtscript_self.property("getDevicePixelRatio");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getDevicePixelRatio";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        double ret =
                        RGraphicsViewWorker::getDevicePixelRatio(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getDevicePixelRatio", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    double res;
                      
                          res = qscriptvalue_cast< 
                            double
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getDevicePixelRatio", engine);

                    
                            return res;
                          
            }
        
    
      bool REcmaShellGraphicsViewWorker::isShared(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::isShared", engine);
                QScriptValue _q_function = __qtscript_self.property("isShared");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::isShared";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        bool ret =
                        RGraphicsViewWorker::isShared(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::isShared", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    bool res;
                      
                          res = qscriptvalue_cast< 
                            bool
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::isShared", engine);

                    
                            return res;
                          
            }
        
    
      bool REcmaShellGraphicsViewWorker::registerForFocus(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::registerForFocus", engine);
                QScriptValue _q_function = __qtscript_self.property("registerForFocus");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::registerForFocus";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        bool ret =
                        RGraphicsViewWorker::registerForFocus(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::registerForFocus", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    bool res;
                      
                          res = qscriptvalue_cast< 
                            bool
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::registerForFocus", engine);

                    
                            return res;
                          
            }
        
    
      void REcmaShellGraphicsViewWorker::setWidget(
                QWidget * w
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::setWidget", engine);
                QScriptValue _q_function = __qtscript_self.property("setWidget");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=1*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::setWidget";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        RGraphicsViewWorker::setWidget(
                            w
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setWidget", engine);

                        
                            return;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    
                            _q_function.call(__qtscript_self,
                                QScriptValueList()
                                



    // type: QWidget *, copyable: false
        << qScriptValueFromValue(engine, 

        w
        )
      
                            )
                        
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::setWidget", engine);

                    
            }
        
    
      QWidget * REcmaShellGraphicsViewWorker::getWidget(
                
            ) {
                QScriptEngine* engine = __qtscript_self.engine();
                //REcmaHelper::shellFunctionStart("REcmaShellGraphicsViewWorker::getWidget", engine);
                QScriptValue _q_function = __qtscript_self.property("getWidget");



                if (!_q_function.isFunction() || 
                    QTSCRIPT_IS_GENERATED_FUNCTION(_q_function) ||
                    QTSCRIPT_IS_FUNCTION_IN_CALL(_q_function)
                    
                    /* function might have more arguments than expected:
                    || _q_function.property("length").toInt32()!=0*/
                    /*|| (__qtscript_self.propertyFlags("atEnd") & QScriptValue::QObjectMember)*/
                    ) {
                    //QString cppSig = "RGraphicsViewWorker::getWidget";
                    
                        // re-enable recursion for calls from C++ into ECMAScript functions
                        // leave it marked as generated though if appropriate:
                        
                        quint32 prev = _q_function.data().toUInt32();
                        //if (cppSig!="RGraphicsViewQt::event") {
                            _q_function.setData(QScriptValue(engine, prev & 0xFFFF0000));
                        //}
                        QWidget * ret =
                        RGraphicsViewWorker::getWidget(
                            
                        );

                        // block recursion again:
                        _q_function.setData(QScriptValue(engine, prev));

                        //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getWidget", engine);

                        
                            return ret;
                          
                }
                    // prevent recursion if script implementation calls base implementation
                    // mark function as 'in call':
                    quint32 prev = _q_function.data().toUInt32();
                    _q_function.setData(QScriptValue(engine, uint(prev | 0x0000B000)));
                    QWidget * res;
                      
                          res = qscriptvalue_cast< 
                            QWidget *
                          >(
                        
                            _q_function.call(__qtscript_self)
                        
                      )
                    
                    ;
                    _q_function.setData(QScriptValue(engine, prev));

                    //REcmaHelper::shellFunctionEnd("REcmaShellGraphicsViewWorker::getWidget", engine);

                    
                            return res;
                          
            }
        
    

    // protected methods (only available for ECMA shell classes) (generated by xsl2xpp.xsl):
	 QScriptValue
        REcmaShellGraphicsViewImage::getTextLayoutsPainterPaths
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaShellGraphicsViewImage::getTextLayoutsPainterPaths", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaShellGraphicsViewImage::getTextLayoutsPainterPaths";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // protected function: can only be called from ECMA shell:
                    REcmaShellGraphicsViewWorker* self = 
                        getSelfShell("", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RTextBasedData */
     && (
            context->argument(1).isArray()
        ) /* type: QList < RTextLayout > */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RTextBasedData*
                    ap0 =
                    qscriptvalue_cast<
                    RTextBasedData*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RTextBasedData.",
                               context);                    
                    }
                    RTextBasedData 
                    a0 = 
                    *ap0;
                
                    // argument isArray or QVariantMap
                    QList < RTextLayout >
                    a1;
                    REcmaHelper::fromScriptValue(
                        engine,
                        context->argument(1),
                        a1
                    );
                
    // end of arguments

    // call C++ function:
    // return type 'QList < RPainterPath >'
    QList < RPainterPath > cppResult =
        
               self->RGraphicsViewImage::getTextLayoutsPainterPaths(a0
        ,
    a1);
        // return type: QList < RPainterPath >
                // List of ...:
                result = REcmaHelper::listToScriptValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getTextLayoutsPainterPaths().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaShellGraphicsViewImage::getTextLayoutsPainterPaths", context, engine);
            return result;
        }
         QScriptValue
        REcmaShellGraphicsViewImage::applyMinimumLineweight
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaShellGraphicsViewImage::applyMinimumLineweight", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaShellGraphicsViewImage::applyMinimumLineweight";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // protected function: can only be called from ECMA shell:
                    REcmaShellGraphicsViewWorker* self = 
                        getSelfShell("", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: QPen */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    QPen*
                    ap0 =
                    qscriptvalue_cast<
                    QPen*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type QPen*.",
                               context);                    
                    }
                    QPen& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->RGraphicsViewImage::applyMinimumLineweight(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.applyMinimumLineweight().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaShellGraphicsViewImage::applyMinimumLineweight", context, engine);
            return result;
        }
         QScriptValue
        REcmaShellGraphicsViewImage::applyColorCorrection
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaShellGraphicsViewImage::applyColorCorrection", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaShellGraphicsViewImage::applyColorCorrection";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // protected function: can only be called from ECMA shell:
                    REcmaShellGraphicsViewWorker* self = 
                        getSelfShell("", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: QPen */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    QPen*
                    ap0 =
                    qscriptvalue_cast<
                    QPen*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type QPen*.",
                               context);                    
                    }
                    QPen& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->RGraphicsViewImage::applyColorCorrection(a0);
    } else


        
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: QBrush */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    QBrush*
                    ap0 =
                    qscriptvalue_cast<
                    QBrush*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type QBrush*.",
                               context);                    
                    }
                    QBrush& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->RGraphicsViewImage::applyColorCorrection(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.applyColorCorrection().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaShellGraphicsViewImage::applyColorCorrection", context, engine);
            return result;
        }
         QScriptValue
        REcmaShellGraphicsViewImage::applyColorMode
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaShellGraphicsViewImage::applyColorMode", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaShellGraphicsViewImage::applyColorMode";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // protected function: can only be called from ECMA shell:
                    REcmaShellGraphicsViewWorker* self = 
                        getSelfShell("", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: QPen */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    QPen*
                    ap0 =
                    qscriptvalue_cast<
                    QPen*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type QPen*.",
                               context);                    
                    }
                    QPen& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->RGraphicsViewImage::applyColorMode(a0);
    } else


        
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: QBrush */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    QBrush*
                    ap0 =
                    qscriptvalue_cast<
                    QBrush*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type QBrush*.",
                               context);                    
                    }
                    QBrush& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->RGraphicsViewImage::applyColorMode(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.applyColorMode().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaShellGraphicsViewImage::applyColorMode", context, engine);
            return result;
        }
         QScriptValue
        REcmaShellGraphicsViewImage::getPointSize
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaShellGraphicsViewImage::getPointSize", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaShellGraphicsViewImage::getPointSize";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // protected function: can only be called from ECMA shell:
                    REcmaShellGraphicsViewWorker* self = 
                        getSelfShell("", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    double
                    a0 =
                    (double)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'double'
    double cppResult =
        
               self->RGraphicsViewImage::getPointSize(a0);
        // return type: double
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getPointSize().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaShellGraphicsViewImage::getPointSize", context, engine);
            return result;
        }
         QScriptValue
        REcmaShellGraphicsViewImage::drawDot
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaShellGraphicsViewImage::drawDot", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaShellGraphicsViewImage::drawDot";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // protected function: can only be called from ECMA shell:
                    REcmaShellGraphicsViewWorker* self = 
                        getSelfShell("", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RGraphicsViewWorker * */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: QPointF */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    RGraphicsViewWorker * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<RGraphicsViewWorker >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RGraphicsViewWorker *RGraphicsViewWorker *.", context);                    
                    }
                
                    // argument is reference
                    QPointF*
                    ap1 =
                    qscriptvalue_cast<
                    QPointF*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if( ap1 == NULL ){
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 1 is not of type QPointF*.",
                               context);                    
                    }
                    QPointF& a1 = *ap1;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->RGraphicsViewImage::drawDot(a0
        ,
    a1);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.drawDot().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaShellGraphicsViewImage::drawDot", context, engine);
            return result;
        }
         QScriptValue
        REcmaShellGraphicsViewImage::drawPlus
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaShellGraphicsViewImage::drawPlus", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaShellGraphicsViewImage::drawPlus";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // protected function: can only be called from ECMA shell:
                    REcmaShellGraphicsViewWorker* self = 
                        getSelfShell("", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    3 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RGraphicsViewWorker * */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: QPointF */
     && (
            context->argument(2).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    RGraphicsViewWorker * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<RGraphicsViewWorker >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RGraphicsViewWorker *RGraphicsViewWorker *.", context);                    
                    }
                
                    // argument is reference
                    QPointF*
                    ap1 =
                    qscriptvalue_cast<
                    QPointF*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if( ap1 == NULL ){
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 1 is not of type QPointF*.",
                               context);                    
                    }
                    QPointF& a1 = *ap1;
                
                    // argument isStandardType
                    double
                    a2 =
                    (double)
                    
                    context->argument( 2 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->RGraphicsViewImage::drawPlus(a0
        ,
    a1
        ,
    a2);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.drawPlus().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaShellGraphicsViewImage::drawPlus", context, engine);
            return result;
        }
         QScriptValue
        REcmaShellGraphicsViewImage::drawEx
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaShellGraphicsViewImage::drawEx", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaShellGraphicsViewImage::drawEx";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // protected function: can only be called from ECMA shell:
                    REcmaShellGraphicsViewWorker* self = 
                        getSelfShell("", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    3 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RGraphicsViewWorker * */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: QPointF */
     && (
            context->argument(2).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    RGraphicsViewWorker * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<RGraphicsViewWorker >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RGraphicsViewWorker *RGraphicsViewWorker *.", context);                    
                    }
                
                    // argument is reference
                    QPointF*
                    ap1 =
                    qscriptvalue_cast<
                    QPointF*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if( ap1 == NULL ){
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 1 is not of type QPointF*.",
                               context);                    
                    }
                    QPointF& a1 = *ap1;
                
                    // argument isStandardType
                    double
                    a2 =
                    (double)
                    
                    context->argument( 2 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->RGraphicsViewImage::drawEx(a0
        ,
    a1
        ,
    a2);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.drawEx().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaShellGraphicsViewImage::drawEx", context, engine);
            return result;
        }
         QScriptValue
        REcmaShellGraphicsViewImage::drawVBar
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaShellGraphicsViewImage::drawVBar", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaShellGraphicsViewImage::drawVBar";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // protected function: can only be called from ECMA shell:
                    REcmaShellGraphicsViewWorker* self = 
                        getSelfShell("", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    3 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RGraphicsViewWorker * */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: QPointF */
     && (
            context->argument(2).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    RGraphicsViewWorker * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<RGraphicsViewWorker >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RGraphicsViewWorker *RGraphicsViewWorker *.", context);                    
                    }
                
                    // argument is reference
                    QPointF*
                    ap1 =
                    qscriptvalue_cast<
                    QPointF*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if( ap1 == NULL ){
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 1 is not of type QPointF*.",
                               context);                    
                    }
                    QPointF& a1 = *ap1;
                
                    // argument isStandardType
                    double
                    a2 =
                    (double)
                    
                    context->argument( 2 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->RGraphicsViewImage::drawVBar(a0
        ,
    a1
        ,
    a2);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.drawVBar().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaShellGraphicsViewImage::drawVBar", context, engine);
            return result;
        }
         QScriptValue
        REcmaShellGraphicsViewImage::drawCircle
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaShellGraphicsViewImage::drawCircle", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaShellGraphicsViewImage::drawCircle";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // protected function: can only be called from ECMA shell:
                    REcmaShellGraphicsViewWorker* self = 
                        getSelfShell("", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    3 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RGraphicsViewWorker * */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: QPointF */
     && (
            context->argument(2).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    RGraphicsViewWorker * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<RGraphicsViewWorker >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RGraphicsViewWorker *RGraphicsViewWorker *.", context);                    
                    }
                
                    // argument is reference
                    QPointF*
                    ap1 =
                    qscriptvalue_cast<
                    QPointF*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if( ap1 == NULL ){
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 1 is not of type QPointF*.",
                               context);                    
                    }
                    QPointF& a1 = *ap1;
                
                    // argument isStandardType
                    double
                    a2 =
                    (double)
                    
                    context->argument( 2 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->RGraphicsViewImage::drawCircle(a0
        ,
    a1
        ,
    a2);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.drawCircle().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaShellGraphicsViewImage::drawCircle", context, engine);
            return result;
        }
         QScriptValue
        REcmaShellGraphicsViewImage::drawSquare
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaShellGraphicsViewImage::drawSquare", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaShellGraphicsViewImage::drawSquare";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // protected function: can only be called from ECMA shell:
                    REcmaShellGraphicsViewWorker* self = 
                        getSelfShell("", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    3 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RGraphicsViewWorker * */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: QPointF */
     && (
            context->argument(2).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    RGraphicsViewWorker * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<RGraphicsViewWorker >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RGraphicsViewWorker *RGraphicsViewWorker *.", context);                    
                    }
                
                    // argument is reference
                    QPointF*
                    ap1 =
                    qscriptvalue_cast<
                    QPointF*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if( ap1 == NULL ){
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 1 is not of type QPointF*.",
                               context);                    
                    }
                    QPointF& a1 = *ap1;
                
                    // argument isStandardType
                    double
                    a2 =
                    (double)
                    
                    context->argument( 2 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->RGraphicsViewImage::drawSquare(a0
        ,
    a1
        ,
    a2);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.drawSquare().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaShellGraphicsViewImage::drawSquare", context, engine);
            return result;
        }
         QScriptValue
        REcmaShellGraphicsViewImage::paintOrigin
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaShellGraphicsViewImage::paintOrigin", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaShellGraphicsViewImage::paintOrigin";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // protected function: can only be called from ECMA shell:
                    REcmaShellGraphicsViewWorker* self = 
                        getSelfShell("", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RGraphicsViewWorker * */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    RGraphicsViewWorker * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<RGraphicsViewWorker >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RGraphicsViewWorker *RGraphicsViewWorker *.", context);                    
                    }
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->RGraphicsViewImage::paintOrigin(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.paintOrigin().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaShellGraphicsViewImage::paintOrigin", context, engine);
            return result;
        }
         QScriptValue
        REcmaShellGraphicsViewImage::paintReferencePoint
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaShellGraphicsViewImage::paintReferencePoint", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaShellGraphicsViewImage::paintReferencePoint";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // protected function: can only be called from ECMA shell:
                    REcmaShellGraphicsViewWorker* self = 
                        getSelfShell("", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    3 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RGraphicsViewWorker * */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: RRefPoint */
     && (
            context->argument(2).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    RGraphicsViewWorker * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<RGraphicsViewWorker >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RGraphicsViewWorker *RGraphicsViewWorker *.", context);                    
                    }
                
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RRefPoint*
                    ap1 =
                    qscriptvalue_cast<
                    RRefPoint*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if (ap1 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 1 is not of type RRefPoint.",
                               context);                    
                    }
                    RRefPoint 
                    a1 = 
                    *ap1;
                
                    // argument isStandardType
                    bool
                    a2 =
                    (bool)
                    
                    context->argument( 2 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->RGraphicsViewImage::paintReferencePoint(a0
        ,
    a1
        ,
    a2);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.paintReferencePoint().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaShellGraphicsViewImage::paintReferencePoint", context, engine);
            return result;
        }
         QScriptValue
        REcmaShellGraphicsViewImage::paintCursor
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaShellGraphicsViewImage::paintCursor", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaShellGraphicsViewImage::paintCursor";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // protected function: can only be called from ECMA shell:
                    REcmaShellGraphicsViewWorker* self = 
                        getSelfShell("", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RGraphicsViewWorker * */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    RGraphicsViewWorker * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<RGraphicsViewWorker >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RGraphicsViewWorker *RGraphicsViewWorker *.", context);                    
                    }
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->RGraphicsViewImage::paintCursor(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.paintCursor().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaShellGraphicsViewImage::paintCursor", context, engine);
            return result;
        }
         QScriptValue
        REcmaShellGraphicsViewImage::paintRelativeZero
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaShellGraphicsViewImage::paintRelativeZero", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaShellGraphicsViewImage::paintRelativeZero";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // protected function: can only be called from ECMA shell:
                    REcmaShellGraphicsViewWorker* self = 
                        getSelfShell("", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RGraphicsViewWorker * */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    RGraphicsViewWorker * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<RGraphicsViewWorker >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RGraphicsViewWorker *RGraphicsViewWorker *.", context);                    
                    }
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->RGraphicsViewImage::paintRelativeZero(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.paintRelativeZero().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaShellGraphicsViewImage::paintRelativeZero", context, engine);
            return result;
        }
         QScriptValue
        REcmaShellGraphicsViewImage::endPaint
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaShellGraphicsViewImage::endPaint", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaShellGraphicsViewImage::endPaint";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // protected function: can only be called from ECMA shell:
                    REcmaShellGraphicsViewWorker* self = 
                        getSelfShell("", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->RGraphicsViewImage::endPaint();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.endPaint().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaShellGraphicsViewImage::endPaint", context, engine);
            return result;
        }
         QScriptValue
        REcmaShellGraphicsViewImage::invalidate
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaShellGraphicsViewImage::invalidate", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaShellGraphicsViewImage::invalidate";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // protected function: can only be called from ECMA shell:
                    REcmaShellGraphicsViewWorker* self = 
                        getSelfShell("", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->RGraphicsViewImage::invalidate();
    } else


        
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->RGraphicsViewImage::invalidate(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.invalidate().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaShellGraphicsViewImage::invalidate", context, engine);
            return result;
        }
         QScriptValue
        REcmaShellGraphicsViewImage::initWorkers
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaShellGraphicsViewImage::initWorkers", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaShellGraphicsViewImage::initWorkers";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // protected function: can only be called from ECMA shell:
                    REcmaShellGraphicsViewWorker* self = 
                        getSelfShell("", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->RGraphicsViewImage::initWorkers();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.initWorkers().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaShellGraphicsViewImage::initWorkers", context, engine);
            return result;
        }
         QScriptValue
        REcmaShellGraphicsViewImage::updateTransformation
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaShellGraphicsViewImage::updateTransformation", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaShellGraphicsViewImage::updateTransformation";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // protected function: can only be called from ECMA shell:
                    REcmaShellGraphicsViewWorker* self = 
                        getSelfShell("", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->RGraphicsViewImage::updateTransformation();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.updateTransformation().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaShellGraphicsViewImage::updateTransformation", context, engine);
            return result;
        }
        