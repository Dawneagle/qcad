// ***** AUTOGENERATED CODE, DO NOT EDIT *****
            // ***** This class is not copyable.
        
        #include "REcmaGraphicsViewImage.h"
        #include "RMetaTypes.h"
        #include "../REcmaHelper.h"

        // forwards declarations mapped to includes
        
                #include "RGraphicsSceneQt.h"
            
                #include "RImageData.h"
            
                #include "RLine.h"
            
                #include "RSnap.h"
            
                #include "RSnapRestriction.h"
            
                #include "RTextBasedData.h"
            
                #include "RTextLayout.h"
            
                #include "RGraphicsViewWorker.h"
            
                #include "RDocument.h"
            
                #include "RDocumentInterface.h"
            
                #include "RTerminateEvent.h"
            
                #include "RMouseEvent.h"
            
            
        // includes for base ecma wrapper classes
        
                  #include "REcmaGraphicsView.h"
                 void REcmaGraphicsViewImage::initEcma(QScriptEngine& engine, QScriptValue* proto 
    
    ) 
    
    {

    bool protoCreated = false;
    if(proto == NULL){
        proto = new QScriptValue(engine.newVariant(qVariantFromValue(
                (RGraphicsViewImage*) 0)));
        protoCreated = true;
    }

    
        // primary base class QObject:
        
            QScriptValue dpt = engine.defaultPrototype(
                qMetaTypeId<QObject*>());

            if (dpt.isValid()) {
                proto->setPrototype(dpt);
            }
          
        /*
        REcmaGraphicsView::initEcma(engine, proto);
          
        */
    

    QScriptValue fun;

    // toString:
    REcmaHelper::registerFunction(&engine, proto, toString, "toString");
    

    // destroy:
    REcmaHelper::registerFunction(&engine, proto, destroy, "destroy");
    
        // conversion for base class QObject
        REcmaHelper::registerFunction(&engine, proto, getQObject, "getQObject");
        
        // conversion for base class RGraphicsView
        REcmaHelper::registerFunction(&engine, proto, getRGraphicsView, "getRGraphicsView");
        

    // get class name
    REcmaHelper::registerFunction(&engine, proto, getClassName, "getClassName");
    

    // conversion to all base classes (multiple inheritance):
    REcmaHelper::registerFunction(&engine, proto, getBaseClasses, "getBaseClasses");
    

        // properties of secondary base class RGraphicsView:
        

        // methods of secondary base class RGraphicsView:
        
            REcmaHelper::registerFunction(&engine, proto, setViewportNumber, "setViewportNumber");
            
            REcmaHelper::registerFunction(&engine, proto, getViewportNumber, "getViewportNumber");
            
            REcmaHelper::registerFunction(&engine, proto, clearCaches, "clearCaches");
            
            REcmaHelper::registerFunction(&engine, proto, setDisplayOnlyCurrentUcs, "setDisplayOnlyCurrentUcs");
            
            REcmaHelper::registerFunction(&engine, proto, getScene, "getScene");
            
            REcmaHelper::registerFunction(&engine, proto, getDocument, "getDocument");
            
            REcmaHelper::registerFunction(&engine, proto, getDocumentInterface, "getDocumentInterface");
            
            REcmaHelper::registerFunction(&engine, proto, mapCornersFromView, "mapCornersFromView");
            
            REcmaHelper::registerFunction(&engine, proto, getBox, "getBox");
            
            REcmaHelper::registerFunction(&engine, proto, getMinimum, "getMinimum");
            
            REcmaHelper::registerFunction(&engine, proto, getMaximum, "getMaximum");
            
            REcmaHelper::registerFunction(&engine, proto, handleTerminateEvent, "handleTerminateEvent");
            
            REcmaHelper::registerFunction(&engine, proto, handleKeyPressEvent, "handleKeyPressEvent");
            
            REcmaHelper::registerFunction(&engine, proto, handleKeyReleaseEvent, "handleKeyReleaseEvent");
            
            REcmaHelper::registerFunction(&engine, proto, handleMouseMoveEvent, "handleMouseMoveEvent");
            
            REcmaHelper::registerFunction(&engine, proto, handleMousePressEvent, "handleMousePressEvent");
            
            REcmaHelper::registerFunction(&engine, proto, handleMouseReleaseEvent, "handleMouseReleaseEvent");
            
            REcmaHelper::registerFunction(&engine, proto, handleMouseDoubleClickEvent, "handleMouseDoubleClickEvent");
            
            REcmaHelper::registerFunction(&engine, proto, handleWheelEvent, "handleWheelEvent");
            
            REcmaHelper::registerFunction(&engine, proto, handleTabletEvent, "handleTabletEvent");
            
            REcmaHelper::registerFunction(&engine, proto, handleSwipeGestureEvent, "handleSwipeGestureEvent");
            
            REcmaHelper::registerFunction(&engine, proto, handlePanGestureEvent, "handlePanGestureEvent");
            
            REcmaHelper::registerFunction(&engine, proto, handlePinchGestureEvent, "handlePinchGestureEvent");
            
            REcmaHelper::registerFunction(&engine, proto, zoomIn, "zoomIn");
            
            REcmaHelper::registerFunction(&engine, proto, zoomOut, "zoomOut");
            
            REcmaHelper::registerFunction(&engine, proto, zoom, "zoom");
            
            REcmaHelper::registerFunction(&engine, proto, zoomTo, "zoomTo");
            
            REcmaHelper::registerFunction(&engine, proto, zoomPrevious, "zoomPrevious");
            
            REcmaHelper::registerFunction(&engine, proto, autoZoom, "autoZoom");
            
            REcmaHelper::registerFunction(&engine, proto, zoomToSelection, "zoomToSelection");
            
            REcmaHelper::registerFunction(&engine, proto, zoomToEntities, "zoomToEntities");
            
            REcmaHelper::registerFunction(&engine, proto, centerToPoint, "centerToPoint");
            
            REcmaHelper::registerFunction(&engine, proto, centerToBox, "centerToBox");
            
            REcmaHelper::registerFunction(&engine, proto, pan, "pan");
            
            REcmaHelper::registerFunction(&engine, proto, startPan, "startPan");
            
            REcmaHelper::registerFunction(&engine, proto, getFactor, "getFactor");
            
            REcmaHelper::registerFunction(&engine, proto, setFactor, "setFactor");
            
            REcmaHelper::registerFunction(&engine, proto, getOffset, "getOffset");
            
            REcmaHelper::registerFunction(&engine, proto, setOffset, "setOffset");
            
            REcmaHelper::registerFunction(&engine, proto, isActive, "isActive");
            
            REcmaHelper::registerFunction(&engine, proto, getSignalsBlocked, "getSignalsBlocked");
            
            REcmaHelper::registerFunction(&engine, proto, setSignalsBlocked, "setSignalsBlocked");
            
            REcmaHelper::registerFunction(&engine, proto, setNavigationAction, "setNavigationAction");
            
            REcmaHelper::registerFunction(&engine, proto, getGrid, "getGrid");
            
            REcmaHelper::registerFunction(&engine, proto, setGrid, "setGrid");
            
            REcmaHelper::registerFunction(&engine, proto, setGridVisible, "setGridVisible");
            
            REcmaHelper::registerFunction(&engine, proto, isGridVisible, "isGridVisible");
            
            REcmaHelper::registerFunction(&engine, proto, paintGridPoints, "paintGridPoints");
            
            REcmaHelper::registerFunction(&engine, proto, getClosestReferencePoint, "getClosestReferencePoint");
            
            REcmaHelper::registerFunction(&engine, proto, getClosestEntity, "getClosestEntity");
            
            REcmaHelper::registerFunction(&engine, proto, getBackgroundColor, "getBackgroundColor");
            
            REcmaHelper::registerFunction(&engine, proto, getMargin, "getMargin");
            
            REcmaHelper::registerFunction(&engine, proto, setMargin, "setMargin");
            
            REcmaHelper::registerFunction(&engine, proto, setExporting, "setExporting");
            
            REcmaHelper::registerFunction(&engine, proto, isExporting, "isExporting");
            
            REcmaHelper::registerFunction(&engine, proto, isPrintingOrExporting, "isPrintingOrExporting");
            
            REcmaHelper::registerFunction(&engine, proto, setPrinting, "setPrinting");
            
            REcmaHelper::registerFunction(&engine, proto, isPrinting, "isPrinting");
            
            REcmaHelper::registerFunction(&engine, proto, setPrintPreview, "setPrintPreview");
            
            REcmaHelper::registerFunction(&engine, proto, isPrintPreview, "isPrintPreview");
            
            REcmaHelper::registerFunction(&engine, proto, setPrintPointSize, "setPrintPointSize");
            
            REcmaHelper::registerFunction(&engine, proto, setColorMode, "setColorMode");
            
            REcmaHelper::registerFunction(&engine, proto, getColorMode, "getColorMode");
            
            REcmaHelper::registerFunction(&engine, proto, setHairlineMode, "setHairlineMode");
            
            REcmaHelper::registerFunction(&engine, proto, getHairlineMode, "getHairlineMode");
            
            REcmaHelper::registerFunction(&engine, proto, setHairlineMinimumMode, "setHairlineMinimumMode");
            
            REcmaHelper::registerFunction(&engine, proto, getHairlineMinimumMode, "getHairlineMinimumMode");
            
            REcmaHelper::registerFunction(&engine, proto, getTextLabels, "getTextLabels");
            
            REcmaHelper::registerFunction(&engine, proto, clearTextLabels, "clearTextLabels");
            
            REcmaHelper::registerFunction(&engine, proto, addTextLabel, "addTextLabel");
            
            REcmaHelper::registerFunction(&engine, proto, getLastKnownMousePosition, "getLastKnownMousePosition");
            
            REcmaHelper::registerFunction(&engine, proto, getCurrentStepScaleFactor, "getCurrentStepScaleFactor");
            
            REcmaHelper::registerFunction(&engine, proto, setCurrentStepScaleFactor, "setCurrentStepScaleFactor");
            
            REcmaHelper::registerFunction(&engine, proto, getCurrentStepOffset, "getCurrentStepOffset");
            
            REcmaHelper::registerFunction(&engine, proto, setCurrentStepOffset, "setCurrentStepOffset");
            
            REcmaHelper::registerFunction(&engine, proto, setTextHeightThresholdOverride, "setTextHeightThresholdOverride");
            
            REcmaHelper::registerFunction(&engine, proto, getTextHeightThresholdOverride, "getTextHeightThresholdOverride");
            
            REcmaHelper::registerFunction(&engine, proto, setForceTextHeightThreshold, "setForceTextHeightThreshold");
            
            REcmaHelper::registerFunction(&engine, proto, getForceTextHeightThreshold, "getForceTextHeightThreshold");
            
            REcmaHelper::registerFunction(&engine, proto, updateTextHeightThreshold, "updateTextHeightThreshold");
            
            REcmaHelper::registerFunction(&engine, proto, isPathVisible, "isPathVisible");
            
            REcmaHelper::registerFunction(&engine, proto, setAntialiasing, "setAntialiasing");
            
            REcmaHelper::registerFunction(&engine, proto, getAntialiasing, "getAntialiasing");
            
            REcmaHelper::registerFunction(&engine, proto, setWidget, "setWidget");
            
            REcmaHelper::registerFunction(&engine, proto, getWidget, "getWidget");
            

    // properties:
    

    // methods:
    
            REcmaHelper::registerFunction(&engine, proto, getNumThreads, "getNumThreads");
            
            REcmaHelper::registerFunction(&engine, proto, setNumThreads, "setNumThreads");
            
            REcmaHelper::registerFunction(&engine, proto, clear, "clear");
            
            REcmaHelper::registerFunction(&engine, proto, setCursor, "setCursor");
            
            REcmaHelper::registerFunction(&engine, proto, getCursor, "getCursor");
            
            REcmaHelper::registerFunction(&engine, proto, simulateMouseMoveEvent, "simulateMouseMoveEvent");
            
            REcmaHelper::registerFunction(&engine, proto, setScene, "setScene");
            
            REcmaHelper::registerFunction(&engine, proto, setBackgroundColor, "setBackgroundColor");
            
            REcmaHelper::registerFunction(&engine, proto, regenerate, "regenerate");
            
            REcmaHelper::registerFunction(&engine, proto, repaintView, "repaintView");
            
            REcmaHelper::registerFunction(&engine, proto, updateImage, "updateImage");
            
            REcmaHelper::registerFunction(&engine, proto, giveFocus, "giveFocus");
            
            REcmaHelper::registerFunction(&engine, proto, hasFocus, "hasFocus");
            
            REcmaHelper::registerFunction(&engine, proto, removeFocus, "removeFocus");
            
            REcmaHelper::registerFunction(&engine, proto, saveViewport, "saveViewport");
            
            REcmaHelper::registerFunction(&engine, proto, restoreViewport, "restoreViewport");
            
            REcmaHelper::registerFunction(&engine, proto, mapFromView, "mapFromView");
            
            REcmaHelper::registerFunction(&engine, proto, mapToView, "mapToView");
            
            REcmaHelper::registerFunction(&engine, proto, mapDistanceFromView, "mapDistanceFromView");
            
            REcmaHelper::registerFunction(&engine, proto, mapDistanceToView, "mapDistanceToView");
            
            REcmaHelper::registerFunction(&engine, proto, getWidth, "getWidth");
            
            REcmaHelper::registerFunction(&engine, proto, getHeight, "getHeight");
            
            REcmaHelper::registerFunction(&engine, proto, resizeImage, "resizeImage");
            
            REcmaHelper::registerFunction(&engine, proto, paintGridPoint, "paintGridPoint");
            
            REcmaHelper::registerFunction(&engine, proto, paintGridLine, "paintGridLine");
            
            REcmaHelper::registerFunction(&engine, proto, paintCursorLine, "paintCursorLine");
            
            REcmaHelper::registerFunction(&engine, proto, setPaintOrigin, "setPaintOrigin");
            
            REcmaHelper::registerFunction(&engine, proto, setPanOptimization, "setPanOptimization");
            
            REcmaHelper::registerFunction(&engine, proto, getPanOptimization, "getPanOptimization");
            
            REcmaHelper::registerFunction(&engine, proto, paintEntities, "paintEntities");
            
            REcmaHelper::registerFunction(&engine, proto, paintEntitiesMulti, "paintEntitiesMulti");
            
            REcmaHelper::registerFunction(&engine, proto, paintEntityThread, "paintEntityThread");
            
            REcmaHelper::registerFunction(&engine, proto, paintDrawableThread, "paintDrawableThread");
            
            REcmaHelper::registerFunction(&engine, proto, paintOverlay, "paintOverlay");
            
            REcmaHelper::registerFunction(&engine, proto, getBuffer, "getBuffer");
            
            REcmaHelper::registerFunction(&engine, proto, getTransform, "getTransform");
            
            REcmaHelper::registerFunction(&engine, proto, clearBackground, "clearBackground");
            
            REcmaHelper::registerFunction(&engine, proto, addToBackground, "addToBackground");
            
            REcmaHelper::registerFunction(&engine, proto, setBackgroundTransform, "setBackgroundTransform");
            
            REcmaHelper::registerFunction(&engine, proto, clearOverlay, "clearOverlay");
            
            REcmaHelper::registerFunction(&engine, proto, addToOverlay, "addToOverlay");
            
            REcmaHelper::registerFunction(&engine, proto, setColorCorrectionOverride, "setColorCorrectionOverride");
            
            REcmaHelper::registerFunction(&engine, proto, getColorCorrectionOverride, "getColorCorrectionOverride");
            
            REcmaHelper::registerFunction(&engine, proto, setMinimumLineweight, "setMinimumLineweight");
            
            REcmaHelper::registerFunction(&engine, proto, getMinimumLineweight, "getMinimumLineweight");
            
            REcmaHelper::registerFunction(&engine, proto, setMaximumLineweight, "setMaximumLineweight");
            
            REcmaHelper::registerFunction(&engine, proto, getMaximumLineweight, "getMaximumLineweight");
            
            REcmaHelper::registerFunction(&engine, proto, setPaintOffset, "setPaintOffset");
            
            REcmaHelper::registerFunction(&engine, proto, getPaintOffset, "getPaintOffset");
            
            REcmaHelper::registerFunction(&engine, proto, isAlphaEnabled, "isAlphaEnabled");
            
            REcmaHelper::registerFunction(&engine, proto, setAlphaEnabled, "setAlphaEnabled");
            
            REcmaHelper::registerFunction(&engine, proto, getDrawingScale, "getDrawingScale");
            
            REcmaHelper::registerFunction(&engine, proto, setDrawingScale, "setDrawingScale");
            
            REcmaHelper::registerFunction(&engine, proto, getGraphicsBufferWithPreview, "getGraphicsBufferWithPreview");
            
            REcmaHelper::registerFunction(&engine, proto, getLastKnownScreenPosition, "getLastKnownScreenPosition");
            
            REcmaHelper::registerFunction(&engine, proto, setLastKnownScreenPosition, "setLastKnownScreenPosition");
            
            REcmaHelper::registerFunction(&engine, proto, setLastKnownModelPosition, "setLastKnownModelPosition");
            
            REcmaHelper::registerFunction(&engine, proto, isShared, "isShared");
            
            REcmaHelper::registerFunction(&engine, proto, registerForFocus, "registerForFocus");
            
            REcmaHelper::registerFunction(&engine, proto, viewportChangeEvent, "viewportChangeEvent");
            
            REcmaHelper::registerFunction(&engine, proto, emitUpdateSnapInfo, "emitUpdateSnapInfo");
            
            REcmaHelper::registerFunction(&engine, proto, emitUpdateTextLabel, "emitUpdateTextLabel");
            
            REcmaHelper::registerFunction(&engine, proto, getDevicePixelRatio, "getDevicePixelRatio");
            
            REcmaHelper::registerFunction(&engine, proto, paintImage, "paintImage");
            
            REcmaHelper::registerFunction(&engine, proto, paintText, "paintText");
            
        engine.setDefaultPrototype(
            qMetaTypeId<RGraphicsViewImage*>(), *proto);

        
                        qScriptRegisterMetaType<
                        RGraphicsViewImage*>(
                        &engine, toScriptValue, fromScriptValue, *proto);
                    
    

    QScriptValue ctor = engine.newFunction(createEcma, *proto, 2);
    
    // static methods:
    

    // static properties:
    

    // enum values:
    

    // enum conversions:
    
        
    // init class:
    engine.globalObject().setProperty("RGraphicsViewImage",
    ctor, QScriptValue::SkipInEnumeration);
    
    if( protoCreated ){
       delete proto;
    }
    
    }
     QScriptValue REcmaGraphicsViewImage::createEcma(QScriptContext* context, QScriptEngine* engine) 
    
    {
    if (context->thisObject().strictlyEquals(
       engine->globalObject())) {
       return REcmaHelper::throwError(
       QString::fromLatin1("RGraphicsViewImage(): Did you forget to construct with 'new'?"),
           context);
    }

    QScriptValue result;
        
            // generate constructor variants:
            
    if( context->argumentCount() ==
        0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ constructor:
    
            // non-copyable class:
            RGraphicsViewImage
                    * cppResult =
                    new
                    RGraphicsViewImage
                    ();
                
                    result = engine->newQObject(context->thisObject(), cppResult, QScriptEngine::QtOwnership);
                
    } else 

    if( context->argumentCount() ==
        1
                && (
                
                        context->argument(
                        0
                        ).isQObject()
                ) /* type: QObject * */
            
    ){
    // prepare arguments:
    
            // argument isQObject
            QObject *
            a0 =
            qobject_cast<
            QObject *>
            ( context->argument(
            0
            ).
            toQObject()
            );
        
    // end of arguments

    // call C++ constructor:
    
            // non-copyable class:
            RGraphicsViewImage
                    * cppResult =
                    new
                    RGraphicsViewImage
                    (
                    a0
                    );
                
                    result = engine->newQObject(context->thisObject(), cppResult, QScriptEngine::QtOwnership);
                
    } else 

    {
       return REcmaHelper::throwError(
       QString::fromLatin1("RGraphicsViewImage(): no matching constructor found."),
           context);
    }
    
    return result;
    }
    

    // conversion functions for base classes:
     QScriptValue REcmaGraphicsViewImage::getQObject(QScriptContext *context,
            QScriptEngine *engine)
        
            {
                QObject* cppResult =
                    qscriptvalue_cast<RGraphicsViewImage*> (context->thisObject());
                QScriptValue result = qScriptValueFromValue(engine, cppResult);
                return result;
            }
             QScriptValue REcmaGraphicsViewImage::getRGraphicsView(QScriptContext *context,
            QScriptEngine *engine)
        
            {
                RGraphicsView* cppResult =
                    qscriptvalue_cast<RGraphicsViewImage*> (context->thisObject());
                QScriptValue result = qScriptValueFromValue(engine, cppResult);
                return result;
            }
            

    // returns class name:
     QScriptValue REcmaGraphicsViewImage::getClassName(QScriptContext *context, QScriptEngine *engine) 
        
    {
        return qScriptValueFromValue(engine, QString("RGraphicsViewImage"));
    }
    

    // returns all base classes (in case of multiple inheritance):
     QScriptValue REcmaGraphicsViewImage::getBaseClasses(QScriptContext *context, QScriptEngine *engine) 
        
    {
        QStringList list;
        
        list.append("QObject");
    
        list.append("RGraphicsView");
    

        return qScriptValueFromSequence(engine, list);
    }
    
        // properties of secondary base class RGraphicsView:
        

        // methods of secondary base class RGraphicsView:
         QScriptValue
        REcmaGraphicsViewImage::setViewportNumber
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setViewportNumber", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setViewportNumber";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setViewportNumber", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: int */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    int
                    a0 =
                    (int)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setViewportNumber(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setViewportNumber().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setViewportNumber", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getViewportNumber
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getViewportNumber", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getViewportNumber";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getViewportNumber", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'int'
    int cppResult =
        
               self->getViewportNumber();
        // return type: int
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getViewportNumber().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getViewportNumber", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::clearCaches
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::clearCaches", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::clearCaches";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("clearCaches", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->clearCaches();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.clearCaches().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::clearCaches", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setDisplayOnlyCurrentUcs
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setDisplayOnlyCurrentUcs", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setDisplayOnlyCurrentUcs";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setDisplayOnlyCurrentUcs", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setDisplayOnlyCurrentUcs(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setDisplayOnlyCurrentUcs().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setDisplayOnlyCurrentUcs", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getScene
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getScene", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getScene";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getScene", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RGraphicsScene *'
    RGraphicsScene * cppResult =
        
               self->getScene();
        // return type: RGraphicsScene *
                // RGraphicsScene:
                result = REcmaHelper::toScriptValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getScene().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getScene", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getDocument
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getDocument", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getDocument";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getDocument", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RDocument *'
    RDocument * cppResult =
        
               self->getDocument();
        // return type: RDocument *
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getDocument().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getDocument", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getDocumentInterface
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getDocumentInterface", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getDocumentInterface";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getDocumentInterface", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RDocumentInterface *'
    RDocumentInterface * cppResult =
        
               self->getDocumentInterface();
        // return type: RDocumentInterface *
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getDocumentInterface().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getDocumentInterface", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::mapCornersFromView
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::mapCornersFromView", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::mapCornersFromView";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("mapCornersFromView", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'QList < RVector >'
    QList < RVector > cppResult =
        
               self->mapCornersFromView();
        // return type: QList < RVector >
                // List of ...:
                result = REcmaHelper::listToScriptValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.mapCornersFromView().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::mapCornersFromView", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getBox
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getBox", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getBox";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getBox", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RBox'
    RBox cppResult =
        
               self->getBox();
        // return type: RBox
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getBox().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getBox", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getMinimum
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getMinimum", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getMinimum";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getMinimum", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->getMinimum();
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getMinimum().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getMinimum", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getMaximum
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getMaximum", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getMaximum";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getMaximum", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->getMaximum();
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getMaximum().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getMaximum", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::handleTerminateEvent
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::handleTerminateEvent", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::handleTerminateEvent";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("handleTerminateEvent", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RTerminateEvent */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    RTerminateEvent*
                    ap0 =
                    qscriptvalue_cast<
                    RTerminateEvent*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){

                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RTerminateEvent* or QSharedPointer<RTerminateEvent>.",
                               context);
                    }
                    RTerminateEvent& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->handleTerminateEvent(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.handleTerminateEvent().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::handleTerminateEvent", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::handleKeyPressEvent
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::handleKeyPressEvent", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::handleKeyPressEvent";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("handleKeyPressEvent", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant()
        ) /* type: QKeyEvent */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    QKeyEvent*
                    ap0 =
                    qscriptvalue_cast<
                    QKeyEvent*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){

                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type QKeyEvent* or QSharedPointer<QKeyEvent>.",
                               context);
                    }
                    QKeyEvent& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->handleKeyPressEvent(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.handleKeyPressEvent().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::handleKeyPressEvent", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::handleKeyReleaseEvent
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::handleKeyReleaseEvent", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::handleKeyReleaseEvent";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("handleKeyReleaseEvent", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant()
        ) /* type: QKeyEvent */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    QKeyEvent*
                    ap0 =
                    qscriptvalue_cast<
                    QKeyEvent*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){

                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type QKeyEvent* or QSharedPointer<QKeyEvent>.",
                               context);
                    }
                    QKeyEvent& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->handleKeyReleaseEvent(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.handleKeyReleaseEvent().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::handleKeyReleaseEvent", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::handleMouseMoveEvent
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::handleMouseMoveEvent", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::handleMouseMoveEvent";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("handleMouseMoveEvent", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RMouseEvent */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    RMouseEvent*
                    ap0 =
                    qscriptvalue_cast<
                    RMouseEvent*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){

                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RMouseEvent* or QSharedPointer<RMouseEvent>.",
                               context);
                    }
                    RMouseEvent& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->handleMouseMoveEvent(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.handleMouseMoveEvent().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::handleMouseMoveEvent", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::handleMousePressEvent
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::handleMousePressEvent", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::handleMousePressEvent";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("handleMousePressEvent", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RMouseEvent */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    RMouseEvent*
                    ap0 =
                    qscriptvalue_cast<
                    RMouseEvent*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){

                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RMouseEvent* or QSharedPointer<RMouseEvent>.",
                               context);
                    }
                    RMouseEvent& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->handleMousePressEvent(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.handleMousePressEvent().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::handleMousePressEvent", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::handleMouseReleaseEvent
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::handleMouseReleaseEvent", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::handleMouseReleaseEvent";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("handleMouseReleaseEvent", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RMouseEvent */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    RMouseEvent*
                    ap0 =
                    qscriptvalue_cast<
                    RMouseEvent*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){

                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RMouseEvent* or QSharedPointer<RMouseEvent>.",
                               context);
                    }
                    RMouseEvent& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->handleMouseReleaseEvent(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.handleMouseReleaseEvent().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::handleMouseReleaseEvent", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::handleMouseDoubleClickEvent
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::handleMouseDoubleClickEvent", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::handleMouseDoubleClickEvent";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("handleMouseDoubleClickEvent", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RMouseEvent */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    RMouseEvent*
                    ap0 =
                    qscriptvalue_cast<
                    RMouseEvent*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){

                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RMouseEvent* or QSharedPointer<RMouseEvent>.",
                               context);
                    }
                    RMouseEvent& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->handleMouseDoubleClickEvent(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.handleMouseDoubleClickEvent().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::handleMouseDoubleClickEvent", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::handleWheelEvent
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::handleWheelEvent", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::handleWheelEvent";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("handleWheelEvent", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RWheelEvent */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    RWheelEvent*
                    ap0 =
                    qscriptvalue_cast<
                    RWheelEvent*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){

                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RWheelEvent* or QSharedPointer<RWheelEvent>.",
                               context);
                    }
                    RWheelEvent& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->handleWheelEvent(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.handleWheelEvent().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::handleWheelEvent", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::handleTabletEvent
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::handleTabletEvent", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::handleTabletEvent";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("handleTabletEvent", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RTabletEvent */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    RTabletEvent*
                    ap0 =
                    qscriptvalue_cast<
                    RTabletEvent*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){

                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RTabletEvent* or QSharedPointer<RTabletEvent>.",
                               context);
                    }
                    RTabletEvent& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->handleTabletEvent(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.handleTabletEvent().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::handleTabletEvent", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::handleSwipeGestureEvent
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::handleSwipeGestureEvent", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::handleSwipeGestureEvent";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("handleSwipeGestureEvent", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: QSwipeGesture */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    QSwipeGesture*
                    ap0 =
                    qscriptvalue_cast<
                    QSwipeGesture*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){

                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type QSwipeGesture* or QSharedPointer<QSwipeGesture>.",
                               context);
                    }
                    QSwipeGesture& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->handleSwipeGestureEvent(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.handleSwipeGestureEvent().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::handleSwipeGestureEvent", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::handlePanGestureEvent
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::handlePanGestureEvent", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::handlePanGestureEvent";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("handlePanGestureEvent", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: QPanGesture */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    QPanGesture*
                    ap0 =
                    qscriptvalue_cast<
                    QPanGesture*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){

                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type QPanGesture* or QSharedPointer<QPanGesture>.",
                               context);
                    }
                    QPanGesture& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->handlePanGestureEvent(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.handlePanGestureEvent().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::handlePanGestureEvent", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::handlePinchGestureEvent
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::handlePinchGestureEvent", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::handlePinchGestureEvent";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("handlePinchGestureEvent", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: QPinchGesture */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    QPinchGesture*
                    ap0 =
                    qscriptvalue_cast<
                    QPinchGesture*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){

                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type QPinchGesture* or QSharedPointer<QPinchGesture>.",
                               context);
                    }
                    QPinchGesture& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->handlePinchGestureEvent(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.handlePinchGestureEvent().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::handlePinchGestureEvent", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::zoomIn
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::zoomIn", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::zoomIn";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("zoomIn", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->zoomIn();
    } else


        
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->zoomIn(a0);
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isStandardType
                    double
                    a1 =
                    (double)
                    
                    context->argument( 1 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->zoomIn(a0
        ,
    a1);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.zoomIn().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::zoomIn", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::zoomOut
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::zoomOut", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::zoomOut";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("zoomOut", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->zoomOut();
    } else


        
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->zoomOut(a0);
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isStandardType
                    double
                    a1 =
                    (double)
                    
                    context->argument( 1 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->zoomOut(a0
        ,
    a1);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.zoomOut().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::zoomOut", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::zoom
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::zoom", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::zoom";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("zoom", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isStandardType
                    double
                    a1 =
                    (double)
                    
                    context->argument( 1 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->zoom(a0
        ,
    a1);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.zoom().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::zoom", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::zoomTo
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::zoomTo", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::zoomTo";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("zoomTo", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RBox */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RBox*
                    ap0 =
                    qscriptvalue_cast<
                    RBox*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RBox.",
                               context);                    
                    }
                    RBox 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->zoomTo(a0);
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RBox */
     && (
            context->argument(1).isNumber()
        ) /* type: int */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RBox*
                    ap0 =
                    qscriptvalue_cast<
                    RBox*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RBox.",
                               context);                    
                    }
                    RBox 
                    a0 = 
                    *ap0;
                
                    // argument isStandardType
                    int
                    a1 =
                    (int)
                    
                    context->argument( 1 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->zoomTo(a0
        ,
    a1);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.zoomTo().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::zoomTo", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::zoomPrevious
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::zoomPrevious", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::zoomPrevious";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("zoomPrevious", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->zoomPrevious();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.zoomPrevious().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::zoomPrevious", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::autoZoom
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::autoZoom", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::autoZoom";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("autoZoom", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->autoZoom();
    } else


        
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: int */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    int
                    a0 =
                    (int)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->autoZoom(a0);
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isNumber()
        ) /* type: int */
     && (
            context->argument(1).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    int
                    a0 =
                    (int)
                    
                    context->argument( 0 ).
                    toNumber();
                
                    // argument isStandardType
                    bool
                    a1 =
                    (bool)
                    
                    context->argument( 1 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->autoZoom(a0
        ,
    a1);
    } else


        
    
    if( context->argumentCount() ==
    3 && (
            context->argument(0).isNumber()
        ) /* type: int */
     && (
            context->argument(1).isBool()
        ) /* type: bool */
     && (
            context->argument(2).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    int
                    a0 =
                    (int)
                    
                    context->argument( 0 ).
                    toNumber();
                
                    // argument isStandardType
                    bool
                    a1 =
                    (bool)
                    
                    context->argument( 1 ).
                    toBool();
                
                    // argument isStandardType
                    bool
                    a2 =
                    (bool)
                    
                    context->argument( 2 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->autoZoom(a0
        ,
    a1
        ,
    a2);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.autoZoom().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::autoZoom", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::zoomToSelection
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::zoomToSelection", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::zoomToSelection";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("zoomToSelection", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->zoomToSelection();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: int */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    int
                    a0 =
                    (int)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->zoomToSelection(a0);
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.zoomToSelection().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::zoomToSelection", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::zoomToEntities
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::zoomToEntities", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::zoomToEntities";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("zoomToEntities", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isArray()
        ) /* type: QSet < RObject::Id > */
    
    ){
    // prepare arguments:
    
                    // argument isArray or QVariantMap
                    QSet < RObject::Id >
                    a0;
                    REcmaHelper::fromScriptValue(
                        engine,
                        context->argument(0),
                        a0
                    );
                
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->zoomToEntities(a0);
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isArray()
        ) /* type: QSet < RObject::Id > */
     && (
            context->argument(1).isNumber()
        ) /* type: int */
    
    ){
    // prepare arguments:
    
                    // argument isArray or QVariantMap
                    QSet < RObject::Id >
                    a0;
                    REcmaHelper::fromScriptValue(
                        engine,
                        context->argument(0),
                        a0
                    );
                
                    // argument isStandardType
                    int
                    a1 =
                    (int)
                    
                    context->argument( 1 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->zoomToEntities(a0
        ,
    a1);
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.zoomToEntities().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::zoomToEntities", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::centerToPoint
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::centerToPoint", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::centerToPoint";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("centerToPoint", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->centerToPoint(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.centerToPoint().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::centerToPoint", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::centerToBox
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::centerToBox", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::centerToBox";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("centerToBox", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RBox */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RBox*
                    ap0 =
                    qscriptvalue_cast<
                    RBox*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RBox.",
                               context);                    
                    }
                    RBox 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->centerToBox(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.centerToBox().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::centerToBox", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::pan
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::pan", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::pan";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("pan", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->pan(a0);
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isStandardType
                    bool
                    a1 =
                    (bool)
                    
                    context->argument( 1 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->pan(a0
        ,
    a1);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.pan().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::pan", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::startPan
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::startPan", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::startPan";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("startPan", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->startPan();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.startPan().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::startPan", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getFactor
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getFactor", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getFactor";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getFactor", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'double'
    double cppResult =
        
               self->getFactor();
        // return type: double
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'double'
    double cppResult =
        
               self->getFactor(a0);
        // return type: double
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getFactor().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getFactor", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setFactor
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setFactor", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setFactor";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setFactor", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    double
                    a0 =
                    (double)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setFactor(a0);
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isNumber()
        ) /* type: double */
     && (
            context->argument(1).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    double
                    a0 =
                    (double)
                    
                    context->argument( 0 ).
                    toNumber();
                
                    // argument isStandardType
                    bool
                    a1 =
                    (bool)
                    
                    context->argument( 1 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setFactor(a0
        ,
    a1);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setFactor().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setFactor", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getOffset
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getOffset", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getOffset";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getOffset", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->getOffset();
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->getOffset(a0);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getOffset().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getOffset", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setOffset
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setOffset", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setOffset";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setOffset", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setOffset(a0);
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isStandardType
                    bool
                    a1 =
                    (bool)
                    
                    context->argument( 1 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setOffset(a0
        ,
    a1);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setOffset().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setOffset", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::isActive
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::isActive", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::isActive";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("isActive", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'int'
    int cppResult =
        
               self->isActive();
        // return type: int
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.isActive().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::isActive", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getSignalsBlocked
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getSignalsBlocked", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getSignalsBlocked";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getSignalsBlocked", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->getSignalsBlocked();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getSignalsBlocked().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getSignalsBlocked", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setSignalsBlocked
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setSignalsBlocked", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setSignalsBlocked";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setSignalsBlocked", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setSignalsBlocked(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setSignalsBlocked().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setSignalsBlocked", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setNavigationAction
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setNavigationAction", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setNavigationAction";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setNavigationAction", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RAction * */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    RAction * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<RAction >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RAction *RAction *.", context);                    
                    }
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setNavigationAction(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setNavigationAction().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setNavigationAction", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getGrid
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getGrid", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getGrid";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getGrid", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RGrid *'
    RGrid * cppResult =
        
               self->getGrid();
        // return type: RGrid *
                // RGrid:
                result = REcmaHelper::toScriptValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getGrid().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getGrid", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setGrid
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setGrid", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setGrid";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setGrid", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RGrid * */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    RGrid * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<RGrid >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RGrid *RGrid *.", context);                    
                    }
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setGrid(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setGrid().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setGrid", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setGridVisible
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setGridVisible", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setGridVisible";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setGridVisible", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setGridVisible(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setGridVisible().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setGridVisible", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::isGridVisible
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::isGridVisible", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::isGridVisible";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("isGridVisible", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->isGridVisible();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.isGridVisible().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::isGridVisible", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::paintGridPoints
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::paintGridPoints", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::paintGridPoints";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("paintGridPoints", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: QVector < double > */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: QVector < double > */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    QVector < double >*
                    ap0 =
                    qscriptvalue_cast<
                    QVector < double >*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){

                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type QVector < double >* or QSharedPointer<QVector < double >>.",
                               context);
                    }
                    QVector < double >& a0 = *ap0;
                
                    // argument is reference
                    QVector < double >*
                    ap1 =
                    qscriptvalue_cast<
                    QVector < double >*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if( ap1 == NULL ){

                           return REcmaHelper::throwError("RGraphicsView: Argument 1 is not of type QVector < double >* or QSharedPointer<QVector < double >>.",
                               context);
                    }
                    QVector < double >& a1 = *ap1;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->paintGridPoints(a0
        ,
    a1);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.paintGridPoints().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::paintGridPoints", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getClosestReferencePoint
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getClosestReferencePoint", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getClosestReferencePoint";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getClosestReferencePoint", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isNumber()
        ) /* type: int */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isStandardType
                    int
                    a1 =
                    (int)
                    
                    context->argument( 1 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'RRefPoint'
    RRefPoint cppResult =
        
               self->getClosestReferencePoint(a0
        ,
    a1);
        // return type: RRefPoint
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isNumber()
        ) /* type: RObject::Id */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    RObject::Id
                    a0 =
                    (RObject::Id)
                    (int)
                    context->argument( 0 ).
                    toNumber();
                
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap1 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if (ap1 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 1 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a1 = 
                    *ap1;
                
    // end of arguments

    // call C++ function:
    // return type 'RRefPoint'
    RRefPoint cppResult =
        
               self->getClosestReferencePoint(a0
        ,
    a1);
        // return type: RRefPoint
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getClosestReferencePoint().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getClosestReferencePoint", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getClosestEntity
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getClosestEntity", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getClosestEntity";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getClosestEntity", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    3 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isNumber()
        ) /* type: int */
     && (
            context->argument(2).isNumber()
        ) /* type: int */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isStandardType
                    int
                    a1 =
                    (int)
                    
                    context->argument( 1 ).
                    toNumber();
                
                    // argument isStandardType
                    int
                    a2 =
                    (int)
                    
                    context->argument( 2 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'RObject::Id'
    RObject::Id cppResult =
        
               self->getClosestEntity(a0
        ,
    a1
        ,
    a2);
        // return type: RObject::Id
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    4 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isNumber()
        ) /* type: int */
     && (
            context->argument(2).isNumber()
        ) /* type: int */
     && (
            context->argument(3).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isStandardType
                    int
                    a1 =
                    (int)
                    
                    context->argument( 1 ).
                    toNumber();
                
                    // argument isStandardType
                    int
                    a2 =
                    (int)
                    
                    context->argument( 2 ).
                    toNumber();
                
                    // argument isStandardType
                    bool
                    a3 =
                    (bool)
                    
                    context->argument( 3 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'RObject::Id'
    RObject::Id cppResult =
        
               self->getClosestEntity(a0
        ,
    a1
        ,
    a2
        ,
    a3);
        // return type: RObject::Id
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    5 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isNumber()
        ) /* type: int */
     && (
            context->argument(2).isNumber()
        ) /* type: int */
     && (
            context->argument(3).isBool()
        ) /* type: bool */
     && (
            context->argument(4).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isStandardType
                    int
                    a1 =
                    (int)
                    
                    context->argument( 1 ).
                    toNumber();
                
                    // argument isStandardType
                    int
                    a2 =
                    (int)
                    
                    context->argument( 2 ).
                    toNumber();
                
                    // argument isStandardType
                    bool
                    a3 =
                    (bool)
                    
                    context->argument( 3 ).
                    toBool();
                
                    // argument isStandardType
                    bool
                    a4 =
                    (bool)
                    
                    context->argument( 4 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'RObject::Id'
    RObject::Id cppResult =
        
               self->getClosestEntity(a0
        ,
    a1
        ,
    a2
        ,
    a3
        ,
    a4);
        // return type: RObject::Id
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getClosestEntity().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getClosestEntity", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getBackgroundColor
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getBackgroundColor", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getBackgroundColor";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getBackgroundColor", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'QColor'
    QColor cppResult =
        
               self->getBackgroundColor();
        // return type: QColor
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getBackgroundColor().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getBackgroundColor", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getMargin
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getMargin", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getMargin";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getMargin", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'int'
    int cppResult =
        
               self->getMargin();
        // return type: int
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getMargin().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getMargin", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setMargin
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setMargin", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setMargin";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setMargin", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: int */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    int
                    a0 =
                    (int)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setMargin(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setMargin().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setMargin", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setExporting
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setExporting", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setExporting";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setExporting", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setExporting(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setExporting().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setExporting", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::isExporting
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::isExporting", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::isExporting";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("isExporting", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->isExporting();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.isExporting().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::isExporting", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::isPrintingOrExporting
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::isPrintingOrExporting", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::isPrintingOrExporting";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("isPrintingOrExporting", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->isPrintingOrExporting();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.isPrintingOrExporting().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::isPrintingOrExporting", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setPrinting
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setPrinting", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setPrinting";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setPrinting", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setPrinting(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setPrinting().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setPrinting", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::isPrinting
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::isPrinting", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::isPrinting";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("isPrinting", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->isPrinting();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.isPrinting().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::isPrinting", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setPrintPreview
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setPrintPreview", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setPrintPreview";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setPrintPreview", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setPrintPreview(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setPrintPreview().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setPrintPreview", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::isPrintPreview
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::isPrintPreview", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::isPrintPreview";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("isPrintPreview", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->isPrintPreview();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.isPrintPreview().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::isPrintPreview", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setPrintPointSize
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setPrintPointSize", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setPrintPointSize";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setPrintPointSize", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setPrintPointSize(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setPrintPointSize().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setPrintPointSize", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setColorMode
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setColorMode", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setColorMode";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setColorMode", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: RGraphicsView::ColorMode */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    RGraphicsView::ColorMode
                    a0 =
                    (RGraphicsView::ColorMode)
                    (int)
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setColorMode(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setColorMode().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setColorMode", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getColorMode
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getColorMode", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getColorMode";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getColorMode", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RGraphicsView::ColorMode'
    RGraphicsView::ColorMode cppResult =
        
               self->getColorMode();
        // return type: RGraphicsView::ColorMode
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getColorMode().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getColorMode", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setHairlineMode
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setHairlineMode", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setHairlineMode";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setHairlineMode", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setHairlineMode(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setHairlineMode().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setHairlineMode", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getHairlineMode
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getHairlineMode", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getHairlineMode";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getHairlineMode", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->getHairlineMode();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getHairlineMode().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getHairlineMode", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setHairlineMinimumMode
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setHairlineMinimumMode", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setHairlineMinimumMode";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setHairlineMinimumMode", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setHairlineMinimumMode(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setHairlineMinimumMode().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setHairlineMinimumMode", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getHairlineMinimumMode
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getHairlineMinimumMode", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getHairlineMinimumMode";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getHairlineMinimumMode", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->getHairlineMinimumMode();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getHairlineMinimumMode().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getHairlineMinimumMode", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getTextLabels
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getTextLabels", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getTextLabels";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getTextLabels", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'QList < RTextLabel >'
    QList < RTextLabel > cppResult =
        
               self->getTextLabels();
        // return type: QList < RTextLabel >
                // List of ...:
                result = REcmaHelper::listToScriptValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getTextLabels().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getTextLabels", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::clearTextLabels
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::clearTextLabels", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::clearTextLabels";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("clearTextLabels", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->clearTextLabels();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.clearTextLabels().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::clearTextLabels", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::addTextLabel
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::addTextLabel", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::addTextLabel";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("addTextLabel", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RTextLabel */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RTextLabel*
                    ap0 =
                    qscriptvalue_cast<
                    RTextLabel*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RTextLabel.",
                               context);                    
                    }
                    RTextLabel 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->addTextLabel(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.addTextLabel().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::addTextLabel", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getLastKnownMousePosition
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getLastKnownMousePosition", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getLastKnownMousePosition";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getLastKnownMousePosition", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->getLastKnownMousePosition();
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getLastKnownMousePosition().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getLastKnownMousePosition", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getCurrentStepScaleFactor
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getCurrentStepScaleFactor", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getCurrentStepScaleFactor";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getCurrentStepScaleFactor", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'double'
    double cppResult =
        
               self->getCurrentStepScaleFactor();
        // return type: double
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getCurrentStepScaleFactor().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getCurrentStepScaleFactor", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setCurrentStepScaleFactor
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setCurrentStepScaleFactor", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setCurrentStepScaleFactor";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setCurrentStepScaleFactor", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    double
                    a0 =
                    (double)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setCurrentStepScaleFactor(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setCurrentStepScaleFactor().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setCurrentStepScaleFactor", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getCurrentStepOffset
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getCurrentStepOffset", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getCurrentStepOffset";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getCurrentStepOffset", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->getCurrentStepOffset();
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getCurrentStepOffset().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getCurrentStepOffset", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setCurrentStepOffset
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setCurrentStepOffset", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setCurrentStepOffset";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setCurrentStepOffset", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setCurrentStepOffset(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setCurrentStepOffset().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setCurrentStepOffset", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setTextHeightThresholdOverride
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setTextHeightThresholdOverride", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setTextHeightThresholdOverride";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setTextHeightThresholdOverride", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: int */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    int
                    a0 =
                    (int)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setTextHeightThresholdOverride(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setTextHeightThresholdOverride().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setTextHeightThresholdOverride", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getTextHeightThresholdOverride
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getTextHeightThresholdOverride", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getTextHeightThresholdOverride";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getTextHeightThresholdOverride", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'int'
    int cppResult =
        
               self->getTextHeightThresholdOverride();
        // return type: int
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getTextHeightThresholdOverride().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getTextHeightThresholdOverride", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setForceTextHeightThreshold
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setForceTextHeightThreshold", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setForceTextHeightThreshold";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setForceTextHeightThreshold", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setForceTextHeightThreshold(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setForceTextHeightThreshold().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setForceTextHeightThreshold", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getForceTextHeightThreshold
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getForceTextHeightThreshold", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getForceTextHeightThreshold";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getForceTextHeightThreshold", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->getForceTextHeightThreshold();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getForceTextHeightThreshold().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getForceTextHeightThreshold", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::updateTextHeightThreshold
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::updateTextHeightThreshold", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::updateTextHeightThreshold";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("updateTextHeightThreshold", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->updateTextHeightThreshold();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.updateTextHeightThreshold().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::updateTextHeightThreshold", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::isPathVisible
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::isPathVisible", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::isPathVisible";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("isPathVisible", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RPainterPath */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RPainterPath*
                    ap0 =
                    qscriptvalue_cast<
                    RPainterPath*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RPainterPath.",
                               context);                    
                    }
                    RPainterPath 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->isPathVisible(a0);
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.isPathVisible().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::isPathVisible", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setAntialiasing
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setAntialiasing", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setAntialiasing";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setAntialiasing", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setAntialiasing(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setAntialiasing().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setAntialiasing", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getAntialiasing
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getAntialiasing", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getAntialiasing";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getAntialiasing", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->getAntialiasing();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getAntialiasing().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getAntialiasing", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setWidget
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setWidget", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setWidget";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setWidget", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: QWidget * */
    
    ){
    // prepare arguments:
    
            // argument isQObject
            QWidget *
            a0 =
            qobject_cast<
            QWidget *>
            ( context->argument(
            0
            ).
            toQObject()
            );
        
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setWidget(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setWidget().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setWidget", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getWidget
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getWidget", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getWidget";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getWidget", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'QWidget *'
    QWidget * cppResult =
        
               self->getWidget();
        // return type: QWidget *
                // QObject
                result = engine->newQObject(cppResult, QScriptEngine::QtOwnership);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getWidget().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getWidget", context, engine);
            return result;
        }
        

    // properties:
    

    // public methods:
     QScriptValue
        REcmaGraphicsViewImage::getNumThreads
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getNumThreads", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getNumThreads";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getNumThreads", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'int'
    int cppResult =
        
               self->getNumThreads();
        // return type: int
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getNumThreads().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getNumThreads", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setNumThreads
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setNumThreads", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setNumThreads";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setNumThreads", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: int */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    int
                    a0 =
                    (int)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setNumThreads(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setNumThreads().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setNumThreads", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::clear
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::clear", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::clear";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("clear", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->clear();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.clear().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::clear", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setCursor
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setCursor", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setCursor";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setCursor", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: Qt::CursorShape */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    Qt::CursorShape
                    a0 =
                    (Qt::CursorShape)
                    (int)
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setCursor(a0);
    } else


        
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: QCursor */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    QCursor*
                    ap0 =
                    qscriptvalue_cast<
                    QCursor*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){

                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type QCursor* or QSharedPointer<QCursor>.",
                               context);
                    }
                    QCursor& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setCursor(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setCursor().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setCursor", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getCursor
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getCursor", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getCursor";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getCursor", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'QCursor'
    QCursor cppResult =
        
               self->getCursor();
        // return type: QCursor
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getCursor().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getCursor", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::simulateMouseMoveEvent
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::simulateMouseMoveEvent", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::simulateMouseMoveEvent";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("simulateMouseMoveEvent", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->simulateMouseMoveEvent();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.simulateMouseMoveEvent().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::simulateMouseMoveEvent", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setScene
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setScene", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setScene";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setScene", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RGraphicsSceneQt * */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    RGraphicsSceneQt * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<RGraphicsSceneQt >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RGraphicsSceneQt *RGraphicsSceneQt *.", context);                    
                    }
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setScene(a0);
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RGraphicsSceneQt * */
     && (
            context->argument(1).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    RGraphicsSceneQt * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<RGraphicsSceneQt >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RGraphicsSceneQt *RGraphicsSceneQt *.", context);                    
                    }
                
                    // argument isStandardType
                    bool
                    a1 =
                    (bool)
                    
                    context->argument( 1 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setScene(a0
        ,
    a1);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setScene().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setScene", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setBackgroundColor
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setBackgroundColor", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setBackgroundColor";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setBackgroundColor", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant()
        ) /* type: QColor */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    QColor*
                    ap0 =
                    qscriptvalue_cast<
                    QColor*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type QColor.",
                               context);                    
                    }
                    QColor 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setBackgroundColor(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setBackgroundColor().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setBackgroundColor", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::regenerate
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::regenerate", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::regenerate";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("regenerate", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->regenerate();
    } else


        
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->regenerate(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.regenerate().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::regenerate", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::repaintView
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::repaintView", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::repaintView";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("repaintView", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->repaintView();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.repaintView().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::repaintView", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::updateImage
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::updateImage", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::updateImage";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("updateImage", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->updateImage();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.updateImage().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::updateImage", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::giveFocus
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::giveFocus", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::giveFocus";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("giveFocus", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->giveFocus();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.giveFocus().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::giveFocus", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::hasFocus
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::hasFocus", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::hasFocus";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("hasFocus", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->hasFocus();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.hasFocus().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::hasFocus", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::removeFocus
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::removeFocus", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::removeFocus";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("removeFocus", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->removeFocus();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.removeFocus().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::removeFocus", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::saveViewport
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::saveViewport", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::saveViewport";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("saveViewport", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->saveViewport();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.saveViewport().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::saveViewport", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::restoreViewport
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::restoreViewport", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::restoreViewport";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("restoreViewport", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->restoreViewport();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.restoreViewport().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::restoreViewport", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::mapFromView
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::mapFromView", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::mapFromView";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("mapFromView", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->mapFromView(a0);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isStandardType
                    double
                    a1 =
                    (double)
                    
                    context->argument( 1 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->mapFromView(a0
        ,
    a1);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.mapFromView().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::mapFromView", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::mapToView
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::mapToView", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::mapToView";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("mapToView", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->mapToView(a0);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.mapToView().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::mapToView", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::mapDistanceFromView
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::mapDistanceFromView", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::mapDistanceFromView";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("mapDistanceFromView", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    double
                    a0 =
                    (double)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'double'
    double cppResult =
        
               self->mapDistanceFromView(a0);
        // return type: double
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.mapDistanceFromView().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::mapDistanceFromView", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::mapDistanceToView
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::mapDistanceToView", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::mapDistanceToView";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("mapDistanceToView", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    double
                    a0 =
                    (double)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'double'
    double cppResult =
        
               self->mapDistanceToView(a0);
        // return type: double
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.mapDistanceToView().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::mapDistanceToView", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getWidth
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getWidth", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getWidth";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getWidth", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'int'
    int cppResult =
        
               self->getWidth();
        // return type: int
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getWidth().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getWidth", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getHeight
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getHeight", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getHeight";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getHeight", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'int'
    int cppResult =
        
               self->getHeight();
        // return type: int
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getHeight().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getHeight", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::resizeImage
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::resizeImage", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::resizeImage";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("resizeImage", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isNumber()
        ) /* type: int */
     && (
            context->argument(1).isNumber()
        ) /* type: int */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    int
                    a0 =
                    (int)
                    
                    context->argument( 0 ).
                    toNumber();
                
                    // argument isStandardType
                    int
                    a1 =
                    (int)
                    
                    context->argument( 1 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->resizeImage(a0
        ,
    a1);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.resizeImage().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::resizeImage", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::paintGridPoint
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::paintGridPoint", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::paintGridPoint";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("paintGridPoint", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->paintGridPoint(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.paintGridPoint().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::paintGridPoint", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::paintGridLine
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::paintGridLine", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::paintGridLine";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("paintGridLine", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RLine */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RLine*
                    ap0 =
                    qscriptvalue_cast<
                    RLine*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RLine.",
                               context);                    
                    }
                    RLine 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->paintGridLine(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.paintGridLine().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::paintGridLine", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::paintCursorLine
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::paintCursorLine", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::paintCursorLine";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("paintCursorLine", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RLine */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RLine*
                    ap0 =
                    qscriptvalue_cast<
                    RLine*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RLine.",
                               context);                    
                    }
                    RLine 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->paintCursorLine(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.paintCursorLine().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::paintCursorLine", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setPaintOrigin
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setPaintOrigin", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setPaintOrigin";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setPaintOrigin", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setPaintOrigin(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setPaintOrigin().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setPaintOrigin", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setPanOptimization
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setPanOptimization", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setPanOptimization";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setPanOptimization", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setPanOptimization(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setPanOptimization().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setPanOptimization", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getPanOptimization
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getPanOptimization", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getPanOptimization";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getPanOptimization", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->getPanOptimization();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getPanOptimization().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getPanOptimization", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::paintEntities
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::paintEntities", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::paintEntities";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("paintEntities", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: QPainter * */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: RBox */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    QPainter * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<QPainter >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type QPainter *QPainter *.", context);                    
                    }
                
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RBox*
                    ap1 =
                    qscriptvalue_cast<
                    RBox*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if (ap1 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 1 is not of type RBox.",
                               context);                    
                    }
                    RBox 
                    a1 = 
                    *ap1;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->paintEntities(a0
        ,
    a1);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.paintEntities().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::paintEntities", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::paintEntitiesMulti
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::paintEntitiesMulti", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::paintEntitiesMulti";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("paintEntitiesMulti", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RBox */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RBox*
                    ap0 =
                    qscriptvalue_cast<
                    RBox*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RBox.",
                               context);                    
                    }
                    RBox 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->paintEntitiesMulti(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.paintEntitiesMulti().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::paintEntitiesMulti", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::paintEntityThread
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::paintEntityThread", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::paintEntityThread";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("paintEntityThread", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isQObject()
        ) /* type: RGraphicsViewWorker * */
     && (
            context->argument(1).isNumber()
        ) /* type: RObject::Id */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    RGraphicsViewWorker * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<RGraphicsViewWorker >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RGraphicsViewWorker *RGraphicsViewWorker *.", context);                    
                    }
                
                    // argument isStandardType
                    RObject::Id
                    a1 =
                    (RObject::Id)
                    (int)
                    context->argument( 1 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->paintEntityThread(a0
        ,
    a1);
    } else


        
    
    if( context->argumentCount() ==
    3 && (
            context->argument(0).isQObject()
        ) /* type: RGraphicsViewWorker * */
     && (
            context->argument(1).isNumber()
        ) /* type: RObject::Id */
     && (
            context->argument(2).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    RGraphicsViewWorker * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<RGraphicsViewWorker >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RGraphicsViewWorker *RGraphicsViewWorker *.", context);                    
                    }
                
                    // argument isStandardType
                    RObject::Id
                    a1 =
                    (RObject::Id)
                    (int)
                    context->argument( 1 ).
                    toNumber();
                
                    // argument isStandardType
                    bool
                    a2 =
                    (bool)
                    
                    context->argument( 2 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->paintEntityThread(a0
        ,
    a1
        ,
    a2);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.paintEntityThread().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::paintEntityThread", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::paintDrawableThread
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::paintDrawableThread", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::paintDrawableThread";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("paintDrawableThread", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    3 && (
            context->argument(0).isQObject()
        ) /* type: RGraphicsViewWorker * */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: RGraphicsSceneDrawable */
     && (
            context->argument(2).isVariant() || 
            context->argument(2).isQObject() || 
            context->argument(2).isNull()
        ) /* type: RBox */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    RGraphicsViewWorker * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<RGraphicsViewWorker >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RGraphicsViewWorker *RGraphicsViewWorker *.", context);                    
                    }
                
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RGraphicsSceneDrawable*
                    ap1 =
                    qscriptvalue_cast<
                    RGraphicsSceneDrawable*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if (ap1 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 1 is not of type RGraphicsSceneDrawable.",
                               context);                    
                    }
                    RGraphicsSceneDrawable 
                    a1 = 
                    *ap1;
                
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RBox*
                    ap2 =
                    qscriptvalue_cast<
                    RBox*
                        >(
                        context->argument(
                        2
                        )
                    );
                    if (ap2 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 2 is not of type RBox.",
                               context);                    
                    }
                    RBox 
                    a2 = 
                    *ap2;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->paintDrawableThread(a0
        ,
    a1
        ,
    a2);
    } else


        
    
    if( context->argumentCount() ==
    4 && (
            context->argument(0).isQObject()
        ) /* type: RGraphicsViewWorker * */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: RGraphicsSceneDrawable */
     && (
            context->argument(2).isVariant() || 
            context->argument(2).isQObject() || 
            context->argument(2).isNull()
        ) /* type: RBox */
     && (
            context->argument(3).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    RGraphicsViewWorker * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<RGraphicsViewWorker >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RGraphicsViewWorker *RGraphicsViewWorker *.", context);                    
                    }
                
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RGraphicsSceneDrawable*
                    ap1 =
                    qscriptvalue_cast<
                    RGraphicsSceneDrawable*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if (ap1 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 1 is not of type RGraphicsSceneDrawable.",
                               context);                    
                    }
                    RGraphicsSceneDrawable 
                    a1 = 
                    *ap1;
                
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RBox*
                    ap2 =
                    qscriptvalue_cast<
                    RBox*
                        >(
                        context->argument(
                        2
                        )
                    );
                    if (ap2 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 2 is not of type RBox.",
                               context);                    
                    }
                    RBox 
                    a2 = 
                    *ap2;
                
                    // argument isStandardType
                    bool
                    a3 =
                    (bool)
                    
                    context->argument( 3 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->paintDrawableThread(a0
        ,
    a1
        ,
    a2
        ,
    a3);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.paintDrawableThread().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::paintDrawableThread", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::paintOverlay
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::paintOverlay", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::paintOverlay";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("paintOverlay", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->paintOverlay();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.paintOverlay().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::paintOverlay", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getBuffer
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getBuffer", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getBuffer";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getBuffer", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'QImage'
    QImage cppResult =
        
               self->getBuffer();
        // return type: QImage
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getBuffer().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getBuffer", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getTransform
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getTransform", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getTransform";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getTransform", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'QTransform'
    QTransform cppResult =
        
               self->getTransform();
        // return type: QTransform
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getTransform().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getTransform", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::clearBackground
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::clearBackground", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::clearBackground";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("clearBackground", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->clearBackground();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.clearBackground().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::clearBackground", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::addToBackground
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::addToBackground", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::addToBackground";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("addToBackground", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RGraphicsSceneDrawable */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RGraphicsSceneDrawable*
                    ap0 =
                    qscriptvalue_cast<
                    RGraphicsSceneDrawable*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RGraphicsSceneDrawable.",
                               context);                    
                    }
                    RGraphicsSceneDrawable 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->addToBackground(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.addToBackground().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::addToBackground", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setBackgroundTransform
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setBackgroundTransform", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setBackgroundTransform";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setBackgroundTransform", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isNumber()
        ) /* type: double */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    double
                    a0 =
                    (double)
                    
                    context->argument( 0 ).
                    toNumber();
                
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap1 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if (ap1 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 1 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a1 = 
                    *ap1;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setBackgroundTransform(a0
        ,
    a1);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setBackgroundTransform().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setBackgroundTransform", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::clearOverlay
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::clearOverlay", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::clearOverlay";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("clearOverlay", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: int */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    int
                    a0 =
                    (int)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->clearOverlay(a0);
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isNumber()
        ) /* type: int */
     && (
            context->argument(1).isNumber()
        ) /* type: RObject::Id */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    int
                    a0 =
                    (int)
                    
                    context->argument( 0 ).
                    toNumber();
                
                    // argument isStandardType
                    RObject::Id
                    a1 =
                    (RObject::Id)
                    (int)
                    context->argument( 1 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->clearOverlay(a0
        ,
    a1);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.clearOverlay().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::clearOverlay", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::addToOverlay
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::addToOverlay", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::addToOverlay";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("addToOverlay", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    3 && (
            context->argument(0).isNumber()
        ) /* type: int */
     && (
            context->argument(1).isNumber()
        ) /* type: RObject::Id */
     && (
            context->argument(2).isVariant() || 
            context->argument(2).isQObject() || 
            context->argument(2).isNull()
        ) /* type: RGraphicsSceneDrawable */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    int
                    a0 =
                    (int)
                    
                    context->argument( 0 ).
                    toNumber();
                
                    // argument isStandardType
                    RObject::Id
                    a1 =
                    (RObject::Id)
                    (int)
                    context->argument( 1 ).
                    toNumber();
                
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RGraphicsSceneDrawable*
                    ap2 =
                    qscriptvalue_cast<
                    RGraphicsSceneDrawable*
                        >(
                        context->argument(
                        2
                        )
                    );
                    if (ap2 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 2 is not of type RGraphicsSceneDrawable.",
                               context);                    
                    }
                    RGraphicsSceneDrawable 
                    a2 = 
                    *ap2;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->addToOverlay(a0
        ,
    a1
        ,
    a2);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.addToOverlay().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::addToOverlay", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setColorCorrectionOverride
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setColorCorrectionOverride", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setColorCorrectionOverride";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setColorCorrectionOverride", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setColorCorrectionOverride(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setColorCorrectionOverride().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setColorCorrectionOverride", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getColorCorrectionOverride
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getColorCorrectionOverride", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getColorCorrectionOverride";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getColorCorrectionOverride", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->getColorCorrectionOverride();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getColorCorrectionOverride().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getColorCorrectionOverride", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setMinimumLineweight
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setMinimumLineweight", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setMinimumLineweight";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setMinimumLineweight", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    double
                    a0 =
                    (double)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setMinimumLineweight(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setMinimumLineweight().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setMinimumLineweight", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getMinimumLineweight
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getMinimumLineweight", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getMinimumLineweight";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getMinimumLineweight", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'double'
    double cppResult =
        
               self->getMinimumLineweight();
        // return type: double
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getMinimumLineweight().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getMinimumLineweight", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setMaximumLineweight
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setMaximumLineweight", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setMaximumLineweight";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setMaximumLineweight", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    double
                    a0 =
                    (double)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setMaximumLineweight(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setMaximumLineweight().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setMaximumLineweight", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getMaximumLineweight
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getMaximumLineweight", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getMaximumLineweight";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getMaximumLineweight", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'double'
    double cppResult =
        
               self->getMaximumLineweight();
        // return type: double
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getMaximumLineweight().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getMaximumLineweight", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setPaintOffset
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setPaintOffset", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setPaintOffset";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setPaintOffset", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setPaintOffset(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setPaintOffset().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setPaintOffset", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getPaintOffset
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getPaintOffset", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getPaintOffset";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getPaintOffset", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->getPaintOffset();
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getPaintOffset().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getPaintOffset", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::isAlphaEnabled
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::isAlphaEnabled", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::isAlphaEnabled";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("isAlphaEnabled", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->isAlphaEnabled();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.isAlphaEnabled().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::isAlphaEnabled", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setAlphaEnabled
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setAlphaEnabled", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setAlphaEnabled";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setAlphaEnabled", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setAlphaEnabled(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setAlphaEnabled().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setAlphaEnabled", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getDrawingScale
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getDrawingScale", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getDrawingScale";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getDrawingScale", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'double'
    double cppResult =
        
               self->getDrawingScale();
        // return type: double
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getDrawingScale().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getDrawingScale", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setDrawingScale
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setDrawingScale", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setDrawingScale";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setDrawingScale", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    double
                    a0 =
                    (double)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setDrawingScale(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setDrawingScale().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setDrawingScale", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getGraphicsBufferWithPreview
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getGraphicsBufferWithPreview", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getGraphicsBufferWithPreview";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getGraphicsBufferWithPreview", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'QImage'
    QImage cppResult =
        
               self->getGraphicsBufferWithPreview();
        // return type: QImage
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getGraphicsBufferWithPreview().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getGraphicsBufferWithPreview", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getLastKnownScreenPosition
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getLastKnownScreenPosition", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getLastKnownScreenPosition";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getLastKnownScreenPosition", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->getLastKnownScreenPosition();
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getLastKnownScreenPosition().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getLastKnownScreenPosition", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setLastKnownScreenPosition
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setLastKnownScreenPosition", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setLastKnownScreenPosition";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setLastKnownScreenPosition", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setLastKnownScreenPosition(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setLastKnownScreenPosition().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setLastKnownScreenPosition", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setLastKnownModelPosition
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setLastKnownModelPosition", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setLastKnownModelPosition";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setLastKnownModelPosition", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setLastKnownModelPosition(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setLastKnownModelPosition().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setLastKnownModelPosition", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::isShared
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::isShared", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::isShared";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("isShared", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->isShared();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.isShared().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::isShared", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::registerForFocus
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::registerForFocus", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::registerForFocus";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("registerForFocus", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->registerForFocus();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.registerForFocus().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::registerForFocus", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::viewportChangeEvent
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::viewportChangeEvent", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::viewportChangeEvent";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("viewportChangeEvent", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->viewportChangeEvent();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.viewportChangeEvent().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::viewportChangeEvent", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::emitUpdateSnapInfo
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::emitUpdateSnapInfo", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::emitUpdateSnapInfo";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("emitUpdateSnapInfo", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RSnap * */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: RSnapRestriction * */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    RSnap * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<RSnap >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RSnap *RSnap *.", context);                    
                    }
                
                    // argument is pointer
                    RSnapRestriction * a1 = NULL;

                    a1 = 
                        REcmaHelper::scriptValueTo<RSnapRestriction >(
                            context->argument(1)
                        );
                    
                    if (a1==NULL && 
                        !context->argument(1).isNull()) {
                        return REcmaHelper::throwError("RGraphicsViewImage: Argument 1 is not of type RSnapRestriction *RSnapRestriction *.", context);                    
                    }
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->emitUpdateSnapInfo(a0
        ,
    a1);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.emitUpdateSnapInfo().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::emitUpdateSnapInfo", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::emitUpdateTextLabel
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::emitUpdateTextLabel", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::emitUpdateTextLabel";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("emitUpdateTextLabel", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RTextLabel */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RTextLabel*
                    ap0 =
                    qscriptvalue_cast<
                    RTextLabel*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RTextLabel.",
                               context);                    
                    }
                    RTextLabel 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->emitUpdateTextLabel(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.emitUpdateTextLabel().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::emitUpdateTextLabel", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getDevicePixelRatio
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getDevicePixelRatio", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getDevicePixelRatio";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getDevicePixelRatio", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'double'
    double cppResult =
        
               self->getDevicePixelRatio();
        // return type: double
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getDevicePixelRatio().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getDevicePixelRatio", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::paintImage
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::paintImage", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::paintImage";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("paintImage", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isQObject()
        ) /* type: RGraphicsViewWorker * */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: RImageData */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    RGraphicsViewWorker * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<RGraphicsViewWorker >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RGraphicsViewWorker *RGraphicsViewWorker *.", context);                    
                    }
                
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RImageData*
                    ap1 =
                    qscriptvalue_cast<
                    RImageData*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if (ap1 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 1 is not of type RImageData.",
                               context);                    
                    }
                    RImageData 
                    a1 = 
                    *ap1;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->paintImage(a0
        ,
    a1);
    } else


        
    
    if( context->argumentCount() ==
    3 && (
            context->argument(0).isQObject()
        ) /* type: RGraphicsViewWorker * */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: RImageData */
     && (
            context->argument(2).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    RGraphicsViewWorker * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<RGraphicsViewWorker >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RGraphicsViewWorker *RGraphicsViewWorker *.", context);                    
                    }
                
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RImageData*
                    ap1 =
                    qscriptvalue_cast<
                    RImageData*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if (ap1 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 1 is not of type RImageData.",
                               context);                    
                    }
                    RImageData 
                    a1 = 
                    *ap1;
                
                    // argument isStandardType
                    bool
                    a2 =
                    (bool)
                    
                    context->argument( 2 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->paintImage(a0
        ,
    a1
        ,
    a2);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.paintImage().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::paintImage", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::paintText
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::paintText", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::paintText";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("paintText", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isQObject()
        ) /* type: RGraphicsViewWorker * */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: RTextBasedData */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    RGraphicsViewWorker * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<RGraphicsViewWorker >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RGraphicsViewWorker *RGraphicsViewWorker *.", context);                    
                    }
                
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RTextBasedData*
                    ap1 =
                    qscriptvalue_cast<
                    RTextBasedData*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if (ap1 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 1 is not of type RTextBasedData.",
                               context);                    
                    }
                    RTextBasedData 
                    a1 = 
                    *ap1;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->paintText(a0
        ,
    a1);
    } else


        
    
    if( context->argumentCount() ==
    3 && (
            context->argument(0).isQObject()
        ) /* type: RGraphicsViewWorker * */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: RTextBasedData */
     && (
            context->argument(2).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    RGraphicsViewWorker * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<RGraphicsViewWorker >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RGraphicsViewWorker *RGraphicsViewWorker *.", context);                    
                    }
                
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RTextBasedData*
                    ap1 =
                    qscriptvalue_cast<
                    RTextBasedData*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if (ap1 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 1 is not of type RTextBasedData.",
                               context);                    
                    }
                    RTextBasedData 
                    a1 = 
                    *ap1;
                
                    // argument isStandardType
                    bool
                    a2 =
                    (bool)
                    
                    context->argument( 2 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->paintText(a0
        ,
    a1
        ,
    a2);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.paintText().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::paintText", context, engine);
            return result;
        }
         QScriptValue REcmaGraphicsViewImage::toString
    (QScriptContext *context, QScriptEngine *engine)
    
    {

    RGraphicsViewImage* self = getSelf("toString", context);
    
    QString result;
    
            result = QString("RGraphicsViewImage(0x%1)").arg((unsigned long int)self, 0, 16);
        
    return QScriptValue(result);
    }
     QScriptValue REcmaGraphicsViewImage::destroy(QScriptContext *context, QScriptEngine *engine)
    
    {

        RGraphicsViewImage* self = getSelf("RGraphicsViewImage", context);
        //Q_ASSERT(self!=NULL);
        if (self==NULL) {
            return REcmaHelper::throwError("self is NULL", context);
        }
        
    
        delete self;
        context->thisObject().setData(engine->nullValue());
        context->thisObject().prototype().setData(engine->nullValue());
        context->thisObject().setPrototype(engine->nullValue());
        context->thisObject().setScriptClass(NULL);
        return engine->undefinedValue();
    }
    RGraphicsViewImage* REcmaGraphicsViewImage::getSelf(const QString& fName, QScriptContext* context)
    
        {
            RGraphicsViewImage* self = NULL;

            
                // self could be a normal object (e.g. from an UI file) or
                // an ECMA shell object (made from an ECMA script):
                //self = getSelfShell(fName, context);
                

            //if (self==NULL) {
                self = REcmaHelper::scriptValueTo<RGraphicsViewImage >(context->thisObject())
                
                ;
            //}

            if (self == NULL){
                // avoid recursion (toString is used by the backtrace):
                if (fName!="toString") {
                    REcmaHelper::throwError(QString("RGraphicsViewImage.%1(): "
                        "This object is not a RGraphicsViewImage").arg(fName),
                        context);
                }
                return NULL;
            }

            return self;
        }
        RGraphicsViewImage* REcmaGraphicsViewImage::getSelfShell(const QString& fName, QScriptContext* context)
    
        {
          RGraphicsViewImage* selfBase = getSelf(fName, context);
                RGraphicsViewImage* self = dynamic_cast<RGraphicsViewImage*>(selfBase);
                //return REcmaHelper::scriptValueTo<RGraphicsViewImage >(context->thisObject());
            if(self == NULL){
                REcmaHelper::throwError(QString("RGraphicsViewImage.%1(): "
                    "This object is not a RGraphicsViewImage").arg(fName),
                    context);
            }

            return self;
            


        }
         void fromScriptValue(const QScriptValue& value,
        RGraphicsViewImage*
        &out) {
            QObject* o = value.toQObject();
            out = qobject_cast<
            RGraphicsViewImage*>(o);
        }
     QScriptValue toScriptValue(QScriptEngine *engine,
        RGraphicsViewImage*
        const &in){
            QScriptValue s = engine->newQObject(in, QScriptEngine::QtOwnership,
            QScriptEngine::PreferExistingWrapperObject);
            /*
            if(s.isNull()){
               REcmaHelper::throwError("This object is null.", engine->currentContext());
            }
            */
            return s;
        }
    